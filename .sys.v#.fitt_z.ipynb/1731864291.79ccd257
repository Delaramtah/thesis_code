{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "61f4200d",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/__init__.py:63: UserWarning: TensorFlow warnings are by default suppressed by zfit. In order to show them, set the environment variable ZFIT_DISABLE_TF_WARNINGS=0. In order to suppress the TensorFlow warnings AND this warning, set ZFIT_DISABLE_TF_WARNINGS=1.\n",
      "  warnings.warn(\n",
      "/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/core/basemodel.py:199: UserWarning: For the future, also decorate _pdf with @supports and specify what you support (such as 'norm=True' to keep the same behavior as before)\n",
      "  warnings.warn(\n"
     ]
    },
    {
     "data": {
      "image/png": "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P/gB3/72t88q09ra2uX2GRkZPPPMM0D3CWLZsmUdyaeiooKEhAQ++OAfE/598MEHLFu2jDVr1nDjjTf255R65Ot8Zs+ezZNPPtnx/plnniEnJyegcfSHJQhjAkRVuePP29hUWMnPVs3jitljufNjOfz7x2aypaiS13efcDtEV1RXV5OamgrAW2+9xQUXXMD111/P7NmzaW1t5dZbb2XhwoXMmTOH+++/H4DDhw+Tm5tLU1MT3/3ud3nqqaeYN28eTz311Bn7Xr58eUeCWLt2LVdeeSVlZWWoKocOHSI2NpYxY8Zw11138ZOf/ASADRs2MGfOHJYuXcqtt95Kbm4u4FyFf/KTn2TFihVMnTqV2267reM4r776KkuXLmXBggV86lOf4vRp544wOzubu+++m3PPPZc//elPZ537xz/+cf76178CUFBQQHJyMunp/xgG6YknnmD27Nnk5uZy++23dyx/5JFHmDZtGueffz7vv/9+x/KysjKuueYaFi5cyMKFC89YNxCsm6sxAbK9pIrntpTytYumcsXssR3Lrz0ni/vfPsj/vbqXi2aMIixs8BqQ//OFnewqre65YC/kZCTxvatmdVumvr6eefPm0dDQwNGjR/n73//ese7DDz9kx44dTJw4kQceeIDk5GQ2bNhAY2Mjy5cv59JLL+1oYI2KiuLuu+8mPz+fX/3qV2cd55xzzmHHjh00NTWxdu1azj//fAoKCti9ezebN29m+fLlZ23zhS98gQceeIBly5Zxxx13nLFuy5YtbN68mejoaKZPn85Xv/pVYmNj+f73v8/rr79OfHw8P/rRj/jpT3/Kd7/7XcB53uC999476zgASUlJjBs3jh07dvDXv/6VVatW8cgjjwBONdrtt9/Oxo0bSU1N5dJLL+W5555j8eLFfO9732Pjxo0kJydzwQUXMH/+fABuueUWvvGNb3DuuedSWFjIZZddxu7dXU3X3nuWIIwJkKfzi4iOCONL557Z7zwyPIxvXDKNW57cwovbj3L13AyXIhw87VVM4FTz3HjjjezYsQOARYsWdfTNf/XVV9m2bVtHdVJVVRX79+9n2rRpfh0nOjqaWbNmsWnTJtatW8dtt91GQUEBa9euZfPmzSxbtuyM8pWVldTU1HQsv/7663nxxRc71l900UUkJzvTmefk5HDkyBEqKyvZtWtXR7Jpampi6dKlHdusWrWq2xhXr17Nk08+ySuvvMIbb7zRkSA2bNjARz/60Y47is985jO88847AGcsX7VqFfv27QPg9ddfZ9euXR37rq6upqamxq/flT8sQRgTAA3NrTy/pZTLc8eQHHv2k6tXzcngN28e5Gev7eOK3DFEhA9ObW9PV/qDYenSpZSXl1NWVgZAfHx8xzpV5Ze//CWXXXbZGdscPny4y/1ddtllHD9+nLy8PB566CGWLVvGO++8Q01NDampqSxZsoRf/epXbN68mTVr1pyxbU/tQNHR0R2vw8PDaWlpQVW55JJLeOKJJ3xu430+vlx11VXceuut5OXlkZSU5FcsXXVRbWtr44MPPiA2NrbbY/aVtUEYEwCv7DxGdUMLn84b53N9WJhw84VTOFRey4eHTw5ydO7as2cPra2tpKWlnbXusssu495776W5uRmAffv2UVtbe0aZxMTEM66SX3nlFbZs2cJDDz0EOO0Q999/P3PnzgVgzpw5rFu3jsLCQmbNOjNBpqamkpiYyLp16wDOaEDuypIlS3j//fc7eiPV1dV1XNH7IzY2lh/96EfceeedZyxfvHgxb7/9NuXl5bS2tvLEE09w/vnns3jxYt566y0qKipobm4+o23j0ksvPaOqrf0ubaBYgjAmAP6UX0xWaixLJp39JdjuwhmjiIoI47VdxwcxMne0t0HMmzePVatW8dhjjxEeHn5WuX/6p38iJyeHBQsWkJuby5e//GVaWlrOKHPBBRewa9cun43U4PRkKigo6Kj2iYiIYNSoUeTl5REWdvZX3sMPP8xNN93E0qVLUdWOKqWupKen8+ijj3LdddcxZ84clixZwp49e3rz62D16tUsWLDgjGVjx47lBz/4ARdccEFHd+CVK1cyduxY7rrrLpYuXcrFF198xnb33HMP+fn5zJkzh5ycHO67775exdGTkJqTOi8vT23CIOO2opN1nPe/b/L1i6Zxy8VTuy37xUc3sO94De/edkHAnnbevXs3M2fODMi+Q8Hp06dJSEgA4Ic//CFHjx7lF7/4hctRBYavvwUR2aiqeb7KB/QOQkRWiMheETkgInf4WD9DRD4QkUYR+Tev5eNE5E0R2S0iO0XklkDGacxAenZTCQDXnJPZY9lLckZTfKqe3UcHrmHR9M7f/vY35s2bR25uLu+++y7f+c533A5pyAhYI7WIhAO/Bi4B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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import uproot\n",
    "import numpy as np\n",
    "import zfit\n",
    "import tensorflow as tf\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Define the ROOT file path\n",
    "root_file_path = \"mass_regionEE.root\"\n",
    "\n",
    "# Open the ROOT file and extract the histogram\n",
    "with uproot.open(root_file_path) as file:\n",
    "    hist = file[\"h_mass_2idpass_EE_hist1;1\"]\n",
    "    hist_values, hist_edges = hist.to_numpy()  # Extract values and edges\n",
    "\n",
    "# Now, hist_values are your y-values (histogram counts), and hist_edges are the x-values (bin edges).\n",
    "# You can use hist_edges to define the x-axis values.\n",
    "\n",
    "# Convert hist_edges to center of bins for x_vals\n",
    "x_vals = (hist_edges[:-1] + hist_edges[1:]) / 2  # Take the average of the bin edges to get the center\n",
    "\n",
    "# Define the observable variable for the PDF\n",
    "x = zfit.Space(\"x\", limits=(70, 110))  # Example range for the mass\n",
    "\n",
    "# Create a zfit Data object for the x values\n",
    "x_vals_data = zfit.Data.from_numpy(array=x_vals, obs=x)  # Pass both the data array and observable\n",
    "\n",
    "# Define the Breit-Wigner function as a custom zfit PDF\n",
    "class BreitWigner(zfit.pdf.BasePDF):\n",
    "    def __init__(self, mass, width, name=\"BreitWigner\", obs=None):\n",
    "        super().__init__(obs=obs, name=name)\n",
    "        self.mass = mass  # Peak mass (mean of Breit-Wigner)\n",
    "        self.width = width  # Width of the Breit-Wigner (Gamma)\n",
    "\n",
    "    def _unnormalized_pdf(self, x):\n",
    "        \"\"\" Return the unnormalized Breit-Wigner function \"\"\"\n",
    "        x_val = x.value()  # Extract the values from the zfit.Data object\n",
    "        return 1 / (np.pi * self.width * (1 + ((x_val - self.mass) / self.width) ** 2))\n",
    "\n",
    "    def _pdf(self, x, norm=True):\n",
    "        \"\"\" Implement the PDF function correctly for zfit with norm handling \"\"\"\n",
    "        unnorm_pdf = self._unnormalized_pdf(x)\n",
    "\n",
    "        if norm:\n",
    "            # Optional: Return the normalized PDF (for now, assume it's already normalized)\n",
    "            return unnorm_pdf\n",
    "        else:\n",
    "            return unnorm_pdf\n",
    "\n",
    "# Define the mass and width for the Breit-Wigner distribution\n",
    "mu = 91.1876  # Mass of the Z boson in GeV\n",
    "sigma = 2.495  # Width of the Z boson in GeV\n",
    "\n",
    "# Create the signal model (Breit-Wigner)\n",
    "signal_model = BreitWigner(mass=mu, width=sigma, obs=x, name=\"SignalModel\")\n",
    "\n",
    "# Define a safe PDF evaluation function with checks for NaN or Inf\n",
    "def safe_pdf_eval(pdf, x_vals_data):\n",
    "    \"\"\" Safely evaluate the PDF with checks for NaN or Inf \"\"\"\n",
    "    result = pdf.pdf(x_vals_data)\n",
    "\n",
    "    if np.any(np.isnan(result)) or np.any(np.isinf(result)):\n",
    "        raise ValueError(f\"NaN or Inf encountered in the PDF evaluation for x_vals={x_vals_data}\")\n",
    "\n",
    "    return result\n",
    "\n",
    "# Evaluate the signal model using safe_pdf_eval\n",
    "signal_model_vals = safe_pdf_eval(signal_model, x_vals_data)\n",
    "\n",
    "# Now you can plot the results or use them for further analysis\n",
    "plt.plot(x_vals, signal_model_vals, label=\"Breit-Wigner Model\")\n",
    "plt.xlabel(\"Mass (GeV)\")\n",
    "plt.ylabel(\"PDF Value\")\n",
    "plt.title(\"Breit-Wigner PDF\")\n",
    "plt.legend()\n",
    "plt.show()\n",
    "\n",
    "# If needed, you can also define a convolution kernel or perform any other operations\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "b6380d47",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/__init__.py:63: UserWarning: TensorFlow warnings are by default suppressed by zfit. In order to show them, set the environment variable ZFIT_DISABLE_TF_WARNINGS=0. In order to suppress the TensorFlow warnings AND this warning, set ZFIT_DISABLE_TF_WARNINGS=1.\n",
      "  warnings.warn(\n"
     ]
    }
   ],
   "source": [
    "import zfit\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.stats import norm\n",
    "import uproot\n",
    "import time  # To add a timestamp for uniqueness\n",
    "\n",
    "# Define ROOT file path\n",
    "root_file_path = \"mass_regionEE.root\"\n",
    "\n",
    "# Open the ROOT file and extract the histogram\n",
    "with uproot.open(root_file_path) as file:\n",
    "    hist = file[\"h_mass_2idpass_EE_hist1;1\"]\n",
    "    hist_values, hist_edges = hist.to_numpy()\n",
    "\n",
    "# Define the number of bins (if you want to reduce the number of bins, adjust this)\n",
    "num_bins_x = 120  # Reduced number of bins\n",
    "\n",
    "# Adjust binning\n",
    "binning = zfit.binned.VariableBinning(hist_edges, name=\"x\")  # 'x' to match the observable's name\n",
    "obs = zfit.Space(\"x\", limits=(hist_edges[0], hist_edges[-1]), binning=binning)\n",
    "\n",
    "# Define categories and signal fractions\n",
    "signal_fraction = {\n",
    "    \"ID_pass\": 0.98\n",
    "}\n",
    "categories = [\"ID_pass\"]\n",
    "\n",
    "# Create BinnedData objects for each category\n",
    "data_dict = {\n",
    "    category: zfit.data.BinnedData.from_tensor(space=obs, values=hist_values)\n",
    "    for category in categories\n",
    "}\n",
    "\n",
    "# Global set to track used parameter names to avoid conflicts\n",
    "used_names = set()\n",
    "\n",
    "# Function to generate a unique parameter name using timestamp\n",
    "def generate_unique_name(base_name):\n",
    "    timestamp = int(time.time() * 1000)  # Get current time in milliseconds\n",
    "    unique_name = f\"{base_name}_{timestamp}\"\n",
    "    while unique_name in used_names:\n",
    "        timestamp += 1  # Increment timestamp until we find a unique one\n",
    "        unique_name = f\"{base_name}_{timestamp}\"\n",
    "    used_names.add(unique_name)\n",
    "    return unique_name\n",
    "\n",
    "# Define the Breit-Wigner function\n",
    "class BreitWignerPDF(zfit.pdf.ZPDF):\n",
    "    _PARAMS = ['M', 'Gamma']\n",
    "\n",
    "    def _unnormalized_pdf(self, x):\n",
    "        M = self.params['M']  # Resonance mass\n",
    "        Gamma = self.params['Gamma']  # Width\n",
    "        x = zfit.z.unstack_x(x)  # Extract the independent variable\n",
    "        numerator = Gamma / 2\n",
    "        denominator = (x - M)**2 + (Gamma / 2)**2\n",
    "        return numerator / denominator\n",
    "\n",
    "# Define models for each category\n",
    "models = {}\n",
    "results = {}\n",
    "\n",
    "for category in categories:\n",
    "    # Generate unique names for the parameters\n",
    "    M_name = generate_unique_name(f\"M_{category}\")\n",
    "    Gamma_name = generate_unique_name(f\"Gamma_{category}\")\n",
    "    mu_kernel_name = generate_unique_name(f\"mu_kernel_{category}\")\n",
    "    sigma_kernel_name = generate_unique_name(f\"sigma_kernel_{category}\")\n",
    "    \n",
    "    # Create parameters with unique names\n",
    "    M = zfit.Parameter(M_name, 90.0, 80.0, 100.0)  # Mean resonance mass\n",
    "    Gamma = zfit.Parameter(Gamma_name, 2.5, 0.1, 10.0)  # Width\n",
    "    \n",
    "    # Signal model (Breit-Wigner)\n",
    "    signal_model = BreitWignerPDF(obs=obs, M=M, Gamma=Gamma)\n",
    "\n",
    "    # Define Gaussian kernel parameters for convolution\n",
    "    mu = zfit.Parameter(mu_kernel_name, 0.0, -5.0, 5.0)\n",
    "    sigma = zfit.Parameter(sigma_kernel_name, 1.0, 0.1, 5.0)\n",
    "    gaussian_kernel = zfit.pdf.Gauss(mu=mu, sigma=sigma, obs=obs)\n",
    "    \n",
    "    # Use FFTConvolution to convolve the Breit-Wigner signal with the Gaussian kernel\n",
    "    signal_model = BreitWignerPDF(obs=obs, M=M, Gamma=Gamma)\n",
    "    signal_convolved = zfit.pdf.FFTConvPDFV1(func=signal_model, kernel=gaussian_kernel)\n",
    "    \n",
    "print(signal_convolved)\n",
    "\n",
    "# # --- Plotting signal_convolved ---\n",
    "# # Create a grid of points over the observable range\n",
    "# x_values = np.linspace(hist_edges[0], hist_edges[-1], 1000)  # 1000 points for smoothness\n",
    "\n",
    "# # Set the parameters with their initial values\n",
    "# parameter_values = {\n",
    "#     M.name: M.value,  # Initial value for M\n",
    "#     Gamma.name: Gamma.value,  # Initial value for Gamma\n",
    "#     mu.name: mu.value,  # Initial value for mu\n",
    "#     sigma.name: sigma.value  # Initial value for sigma\n",
    "# }\n",
    "\n",
    "# # Evaluate the convolved signal PDF on the grid\n",
    "# with zfit.param.set_values(parameter_values):  # Pass the dictionary of parameter values\n",
    "#     y_values = signal_convolved.pdf(x_values).numpy()\n",
    "\n",
    "# # Plot the signal_convolved PDF\n",
    "# plt.figure(figsize=(10, 6))\n",
    "# plt.plot(x_values, y_values, label=\"Convolved Signal PDF\", color='blue')\n",
    "# plt.xlabel(\"x (observable)\")\n",
    "# plt.ylabel(\"PDF\")\n",
    "# plt.title(\"Convolved Signal (Breit-Wigner and Gaussian Kernel)\")\n",
    "# plt.legend()\n",
    "# plt.grid()\n",
    "# plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "1bf919cd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Breit-Wigner PDF values: [0.00212706 0.00213614 0.00214528 0.00215448 0.00216374 0.00217306\n",
      " 0.00218244 0.00219187 0.00220137 0.00221093]\n",
      "Error with Gaussian kernel: {{function_node __wrapped__CheckNumerics_device_/job:localhost/replica:0/task:0/device:CPU:0}} Check if pdf output contains any NaNs of Infs : Tensor had NaN values [Op:CheckNumerics] name: \n",
      "Error with convolution: {{function_node __wrapped__CheckNumerics_device_/job:localhost/replica:0/task:0/device:CPU:0}} Check if pdf output contains any NaNs of Infs : Tensor had NaN values [Op:CheckNumerics] name: \n"
     ]
    }
   ],
   "source": [
    "import zfit\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.stats import norm\n",
    "import uproot\n",
    "import time  # For timestamp-based unique names\n",
    "\n",
    "# Define ROOT file path\n",
    "root_file_path = \"mass_regionEE.root\"\n",
    "\n",
    "# Open the ROOT file and extract the histogram\n",
    "with uproot.open(root_file_path) as file:\n",
    "    hist = file[\"h_mass_2idpass_EE_hist1;1\"]\n",
    "    hist_values, hist_edges = hist.to_numpy()\n",
    "\n",
    "# Define the number of bins (if you want to reduce the number of bins, adjust this)\n",
    "num_bins_x = 120  # Reduced number of bins\n",
    "\n",
    "# Adjust binning\n",
    "binning = zfit.binned.VariableBinning(hist_edges, name=\"x\")  # 'x' to match the observable's name\n",
    "obs = zfit.Space(\"x\", limits=(hist_edges[0], hist_edges[-1]), binning=binning)\n",
    "\n",
    "# Define categories and signal fractions\n",
    "signal_fraction = {\n",
    "    \"ID_pass\": 0.98\n",
    "}\n",
    "categories = [\"ID_pass\"]\n",
    "\n",
    "# Create BinnedData objects for each category\n",
    "data_dict = {\n",
    "    category: zfit.data.BinnedData.from_tensor(space=obs, values=hist_values)\n",
    "    for category in categories\n",
    "}\n",
    "\n",
    "# Global set to track used parameter names to avoid conflicts\n",
    "used_names = set()\n",
    "\n",
    "# Function to generate a unique parameter name using timestamp\n",
    "def generate_unique_name(base_name):\n",
    "    timestamp = int(time.time() * 1000)  # Get current time in milliseconds\n",
    "    unique_name = f\"{base_name}_{timestamp}\"\n",
    "    while unique_name in used_names:\n",
    "        timestamp += 1  # Increment timestamp until we find a unique one\n",
    "        unique_name = f\"{base_name}_{timestamp}\"\n",
    "    used_names.add(unique_name)\n",
    "    return unique_name\n",
    "\n",
    "# Define the Breit-Wigner function\n",
    "class BreitWignerPDF(zfit.pdf.ZPDF):\n",
    "    _PARAMS = ['M', 'Gamma']\n",
    "\n",
    "    def _unnormalized_pdf(self, x):\n",
    "        M = self.params['M']  # Resonance mass\n",
    "        Gamma = self.params['Gamma']  # Width\n",
    "        x = zfit.z.unstack_x(x)  # Extract the independent variable\n",
    "        numerator = Gamma / 2\n",
    "        denominator = (x - M)**2 + (Gamma / 2)**2\n",
    "        return numerator / denominator\n",
    "\n",
    "# Define models for each category\n",
    "models = {}\n",
    "results = {}\n",
    "\n",
    "for category in categories:\n",
    "    # Generate unique names for the parameters\n",
    "    M_name = generate_unique_name(f\"M_{category}\")\n",
    "    Gamma_name = generate_unique_name(f\"Gamma_{category}\")\n",
    "    mu_kernel_name = generate_unique_name(f\"mu_kernel_{category}\")\n",
    "    sigma_kernel_name = generate_unique_name(f\"sigma_kernel_{category}\")\n",
    "    \n",
    "    # Create parameters with unique names\n",
    "    M = zfit.Parameter(M_name, 90.0, 80.0, 100.0)  # Mean resonance mass\n",
    "    Gamma = zfit.Parameter(Gamma_name, 2.5, 0.1, 10.0)  # Width\n",
    "    \n",
    "    # Signal model (Breit-Wigner)\n",
    "    signal_model = BreitWignerPDF(obs=obs, M=M, Gamma=Gamma)\n",
    "\n",
    "    # Define Gaussian kernel parameters for convolution\n",
    "    mu = zfit.Parameter(mu_kernel_name, 0.0, -5.0, 5.0)\n",
    "    sigma = zfit.Parameter(sigma_kernel_name, 2.0, 0.1, 5.0)  # Increased sigma to improve stability\n",
    "    gaussian_kernel = zfit.pdf.Gauss(mu=mu, sigma=sigma, obs=obs)\n",
    "\n",
    "# --- Debugging: Check individual PDFs before convolution ---\n",
    "# Create a grid of points over the observable range\n",
    "x_values = np.linspace(hist_edges[0], hist_edges[-1], 1000)  # 1000 points for smoothness\n",
    "\n",
    "# Set the parameter values directly\n",
    "M.set_value(90.0)    # Initial value for M\n",
    "Gamma.set_value(2.5) # Initial value for Gamma\n",
    "mu.set_value(0.0)    # Initial value for mu (Gaussian kernel)\n",
    "sigma.set_value(2.0) # Increased value for sigma (Gaussian kernel)\n",
    "\n",
    "# Check the Breit-Wigner PDF before convolution\n",
    "bw_values = signal_model.pdf(x_values).numpy()\n",
    "print(\"Breit-Wigner PDF values:\", bw_values[:10])  # Print first 10 values\n",
    "\n",
    "# --- Debugging: Check Gaussian kernel separately ---\n",
    "try:\n",
    "    # Check the Gaussian kernel PDF separately\n",
    "    gaussian_values = gaussian_kernel.pdf(x_values).numpy()\n",
    "    if np.any(np.isnan(gaussian_values)) or np.any(np.isinf(gaussian_values)):\n",
    "        print(\"Warning: Gaussian kernel produced NaNs or Infs!\")\n",
    "    else:\n",
    "        print(\"Gaussian Kernel PDF values:\", gaussian_values[:10])  # Print first 10 values\n",
    "except Exception as e:\n",
    "    print(f\"Error with Gaussian kernel: {e}\")\n",
    "\n",
    "# --- Checking if the convolution introduces instability ---\n",
    "# Now evaluate the convolved signal PDF on the grid\n",
    "try:\n",
    "    y_values = signal_convolved.pdf(x_values).numpy()\n",
    "\n",
    "    # Check if the output contains NaNs or Infs\n",
    "    if np.any(np.isnan(y_values)) or np.any(np.isinf(y_values)):\n",
    "        print(\"Warning: Convolution result contains NaNs or Infs!\")\n",
    "    else:\n",
    "        # Plot the signal_convolved PDF\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        plt.plot(x_values, y_values, label=\"Convolved Signal PDF\", color='blue')\n",
    "        plt.xlabel(\"x (observable)\")\n",
    "        plt.ylabel(\"PDF\")\n",
    "        plt.title(\"Convolved Signal (Breit-Wigner and Gaussian Kernel)\")\n",
    "        plt.legend()\n",
    "        plt.grid()\n",
    "        plt.show()\n",
    "except Exception as e:\n",
    "    print(f\"Error with convolution: {e}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "6dd08f3a",
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "import uproot\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "root_file_path = \"mass_regionEE.root\"\n",
    "\n",
    "# Open the ROOT file and extract the histogram\n",
    "with uproot.open(root_file_path) as file:\n",
    "    hist = file[\"h_mass_2idpass_EE_hist1;1\"]\n",
    "    hist_values, hist_edges = hist.to_numpy()\n",
    "\n",
    "# The histogram data\n",
    "x_data = (hist_edges[:-1] + hist_edges[1:]) / 2  # Bin centers\n",
    "y_data = hist_values  # Bin contents\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8ea4a049",
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "91cee652",
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "668962fa",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
