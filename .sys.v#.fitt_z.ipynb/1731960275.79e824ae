{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "61f4200d",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/__init__.py:63: UserWarning: TensorFlow warnings are by default suppressed by zfit. In order to show them, set the environment variable ZFIT_DISABLE_TF_WARNINGS=0. In order to suppress the TensorFlow warnings AND this warning, set ZFIT_DISABLE_TF_WARNINGS=1.\n",
      "  warnings.warn(\n",
      "/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/core/basemodel.py:199: UserWarning: For the future, also decorate _pdf with @supports and specify what you support (such as 'norm=True' to keep the same behavior as before)\n",
      "  warnings.warn(\n"
     ]
    },
    {
     "data": {
      "image/png": "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P/gB3/72t88q09ra2uX2GRkZPPPMM0D3CWLZsmUdyaeiooKEhAQ++OAfE/598MEHLFu2jDVr1nDjjTf255R65Ot8Zs+ezZNPPtnx/plnniEnJyegcfSHJQhjAkRVuePP29hUWMnPVs3jitljufNjOfz7x2aypaiS13efcDtEV1RXV5OamgrAW2+9xQUXXMD111/P7NmzaW1t5dZbb2XhwoXMmTOH+++/H4DDhw+Tm5tLU1MT3/3ud3nqqaeYN28eTz311Bn7Xr58eUeCWLt2LVdeeSVlZWWoKocOHSI2NpYxY8Zw11138ZOf/ASADRs2MGfOHJYuXcqtt95Kbm4u4FyFf/KTn2TFihVMnTqV2267reM4r776KkuXLmXBggV86lOf4vRp544wOzubu+++m3PPPZc//elPZ537xz/+cf76178CUFBQQHJyMunp/xgG6YknnmD27Nnk5uZy++23dyx/5JFHmDZtGueffz7vv/9+x/KysjKuueYaFi5cyMKFC89YNxCsm6sxAbK9pIrntpTytYumcsXssR3Lrz0ni/vfPsj/vbqXi2aMIixs8BqQ//OFnewqre65YC/kZCTxvatmdVumvr6eefPm0dDQwNGjR/n73//ese7DDz9kx44dTJw4kQceeIDk5GQ2bNhAY2Mjy5cv59JLL+1oYI2KiuLuu+8mPz+fX/3qV2cd55xzzmHHjh00NTWxdu1azj//fAoKCti9ezebN29m+fLlZ23zhS98gQceeIBly5Zxxx13nLFuy5YtbN68mejoaKZPn85Xv/pVYmNj+f73v8/rr79OfHw8P/rRj/jpT3/Kd7/7XcB53uC999476zgASUlJjBs3jh07dvDXv/6VVatW8cgjjwBONdrtt9/Oxo0bSU1N5dJLL+W5555j8eLFfO9732Pjxo0kJydzwQUXMH/+fABuueUWvvGNb3DuuedSWFjIZZddxu7dXU3X3nuWIIwJkKfzi4iOCONL557Z7zwyPIxvXDKNW57cwovbj3L13AyXIhw87VVM4FTz3HjjjezYsQOARYsWdfTNf/XVV9m2bVtHdVJVVRX79+9n2rRpfh0nOjqaWbNmsWnTJtatW8dtt91GQUEBa9euZfPmzSxbtuyM8pWVldTU1HQsv/7663nxxRc71l900UUkJzvTmefk5HDkyBEqKyvZtWtXR7Jpampi6dKlHdusWrWq2xhXr17Nk08+ySuvvMIbb7zRkSA2bNjARz/60Y47is985jO88847AGcsX7VqFfv27QPg9ddfZ9euXR37rq6upqamxq/flT8sQRgTAA3NrTy/pZTLc8eQHHv2k6tXzcngN28e5Gev7eOK3DFEhA9ObW9PV/qDYenSpZSXl1NWVgZAfHx8xzpV5Ze//CWXXXbZGdscPny4y/1ddtllHD9+nLy8PB566CGWLVvGO++8Q01NDampqSxZsoRf/epXbN68mTVr1pyxbU/tQNHR0R2vw8PDaWlpQVW55JJLeOKJJ3xu430+vlx11VXceuut5OXlkZSU5FcsXXVRbWtr44MPPiA2NrbbY/aVtUEYEwCv7DxGdUMLn84b53N9WJhw84VTOFRey4eHTw5ydO7as2cPra2tpKWlnbXusssu495776W5uRmAffv2UVtbe0aZxMTEM66SX3nlFbZs2cJDDz0EOO0Q999/P3PnzgVgzpw5rFu3jsLCQmbNOjNBpqamkpiYyLp16wDOaEDuypIlS3j//fc7eiPV1dV1XNH7IzY2lh/96EfceeedZyxfvHgxb7/9NuXl5bS2tvLEE09w/vnns3jxYt566y0qKipobm4+o23j0ksvPaOqrf0ubaBYgjAmAP6UX0xWaixLJp39JdjuwhmjiIoI47VdxwcxMne0t0HMmzePVatW8dhjjxEeHn5WuX/6p38iJyeHBQsWkJuby5e//GVaWlrOKHPBBRewa9cun43U4PRkKigo6Kj2iYiIYNSoUeTl5REWdvZX3sMPP8xNN93E0qVLUdWOKqWupKen8+ijj3LdddcxZ84clixZwp49e3rz62D16tUsWLDgjGVjx47lBz/4ARdccEFHd+CVK1cyduxY7rrrLpYuXcrFF198xnb33HMP+fn5zJkzh5ycHO67775exdGTkJqTOi8vT23CIOO2opN1nPe/b/L1i6Zxy8VTuy37xUc3sO94De/edkHAnnbevXs3M2fODMi+Q8Hp06dJSEgA4Ic//CFHjx7lF7/4hctRBYavvwUR2aiqeb7KB/QOQkRWiMheETkgInf4WD9DRD4QkUYR+Tev5eNE5E0R2S0iO0XklkDGacxAenZTCQDXnJPZY9lLckZTfKqe3UcHrmHR9M7f/vY35s2bR25uLu+++y7f+c533A5pyAhYI7WIhAO/Bi4B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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import uproot\n",
    "import numpy as np\n",
    "import zfit\n",
    "import tensorflow as tf\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Define the ROOT file path\n",
    "root_file_path = \"mass_regionEE.root\"\n",
    "\n",
    "# Open the ROOT file and extract the histogram\n",
    "with uproot.open(root_file_path) as file:\n",
    "    hist = file[\"h_mass_2idpass_EE_hist1;1\"]\n",
    "    hist_values, hist_edges = hist.to_numpy()  # Extract values and edges\n",
    "\n",
    "# Now, hist_values are your y-values (histogram counts), and hist_edges are the x-values (bin edges).\n",
    "# You can use hist_edges to define the x-axis values.\n",
    "\n",
    "# Convert hist_edges to center of bins for x_vals\n",
    "x_vals = (hist_edges[:-1] + hist_edges[1:]) / 2  # Take the average of the bin edges to get the center\n",
    "\n",
    "# Define the observable variable for the PDF\n",
    "x = zfit.Space(\"x\", limits=(70, 110))  # Example range for the mass\n",
    "\n",
    "# Create a zfit Data object for the x values\n",
    "x_vals_data = zfit.Data.from_numpy(array=x_vals, obs=x)  # Pass both the data array and observable\n",
    "\n",
    "# Define the Breit-Wigner function as a custom zfit PDF\n",
    "class BreitWigner(zfit.pdf.BasePDF):\n",
    "    def __init__(self, mass, width, name=\"BreitWigner\", obs=None):\n",
    "        super().__init__(obs=obs, name=name)\n",
    "        self.mass = mass  # Peak mass (mean of Breit-Wigner)\n",
    "        self.width = width  # Width of the Breit-Wigner (Gamma)\n",
    "\n",
    "    def _unnormalized_pdf(self, x):\n",
    "        \"\"\" Return the unnormalized Breit-Wigner function \"\"\"\n",
    "        x_val = x.value()  # Extract the values from the zfit.Data object\n",
    "        return 1 / (np.pi * self.width * (1 + ((x_val - self.mass) / self.width) ** 2))\n",
    "\n",
    "    def _pdf(self, x, norm=True):\n",
    "        \"\"\" Implement the PDF function correctly for zfit with norm handling \"\"\"\n",
    "        unnorm_pdf = self._unnormalized_pdf(x)\n",
    "\n",
    "        if norm:\n",
    "            # Optional: Return the normalized PDF (for now, assume it's already normalized)\n",
    "            return unnorm_pdf\n",
    "        else:\n",
    "            return unnorm_pdf\n",
    "\n",
    "# Define the mass and width for the Breit-Wigner distribution\n",
    "mu = 91.1876  # Mass of the Z boson in GeV\n",
    "sigma = 2.495  # Width of the Z boson in GeV\n",
    "\n",
    "# Create the signal model (Breit-Wigner)\n",
    "signal_model = BreitWigner(mass=mu, width=sigma, obs=x, name=\"SignalModel\")\n",
    "\n",
    "# Define a safe PDF evaluation function with checks for NaN or Inf\n",
    "def safe_pdf_eval(pdf, x_vals_data):\n",
    "    \"\"\" Safely evaluate the PDF with checks for NaN or Inf \"\"\"\n",
    "    result = pdf.pdf(x_vals_data)\n",
    "\n",
    "    if np.any(np.isnan(result)) or np.any(np.isinf(result)):\n",
    "        raise ValueError(f\"NaN or Inf encountered in the PDF evaluation for x_vals={x_vals_data}\")\n",
    "\n",
    "    return result\n",
    "\n",
    "# Evaluate the signal model using safe_pdf_eval\n",
    "signal_model_vals = safe_pdf_eval(signal_model, x_vals_data)\n",
    "\n",
    "# Now you can plot the results or use them for further analysis\n",
    "plt.plot(x_vals, signal_model_vals, label=\"Breit-Wigner Model\")\n",
    "plt.xlabel(\"Mass (GeV)\")\n",
    "plt.ylabel(\"PDF Value\")\n",
    "plt.title(\"Breit-Wigner PDF\")\n",
    "plt.legend()\n",
    "plt.show()\n",
    "\n",
    "# If needed, you can also define a convolution kernel or perform any other operations\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "b6380d47",
   "metadata": {},
   "outputs": [
    {
     "ename": "InvalidArgumentError",
     "evalue": "{{function_node __wrapped__CheckNumerics_device_/job:localhost/replica:0/task:0/device:CPU:0}} Check if pdf output contains any NaNs of Infs : Tensor had NaN values [Op:CheckNumerics] name: ",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mInvalidArgumentError\u001b[0m                      Traceback (most recent call last)",
      "\u001b[0;32m/tmp/ipykernel_456/2932372208.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     88\u001b[0m     \u001b[0mx\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlinspace\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1000\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnum\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m10000\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     89\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 90\u001b[0;31m     \u001b[0my\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0msignal_convolved\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpdf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     91\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     92\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/tensorflow/python/util/deprecation.py\u001b[0m in \u001b[0;36mnew_func\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m    574\u001b[0m                 \u001b[0;34m'in a future version'\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0mdate\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;32melse\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m'after %s'\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mdate\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    575\u001b[0m                 instructions)\n\u001b[0;32m--> 576\u001b[0;31m       \u001b[0;32mreturn\u001b[0m \u001b[0mfunc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    577\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    578\u001b[0m     doc = _add_deprecated_arg_notice_to_docstring(\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/util/deprecation.py\u001b[0m in \u001b[0;36mwrapper\u001b[0;34m(norm, norm_range, *args, **kwargs)\u001b[0m\n\u001b[1;32m     14\u001b[0m             \u001b[0mnorm\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnorm_range\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     15\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 16\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mfunc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnorm\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mnorm\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     17\u001b[0m         \u001b[0;32mexcept\u001b[0m \u001b[0mTypeError\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0merror\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     18\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0;34m\"unexpected keyword argument 'norm'\"\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0merror\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/z/zextension.py\u001b[0m in \u001b[0;36mconcrete_func\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m    245\u001b[0m         \u001b[0;32mdef\u001b[0m \u001b[0mconcrete_func\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    246\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdo_jit\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0mfunc\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcurrently_traced\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 247\u001b[0;31m                 \u001b[0;32mreturn\u001b[0m \u001b[0mfunc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    248\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    249\u001b[0m             \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcurrently_traced\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0madd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfunc\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/core/basepdf.py\u001b[0m in \u001b[0;36mpdf\u001b[0;34m(***failed resolving arguments***)\u001b[0m\n\u001b[1;32m    408\u001b[0m             \u001b[0mvalue\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_single_hook_pdf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnorm\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mnorm\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    409\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mrun\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnumeric_checks\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 410\u001b[0;31m                 z.check_numerics(\n\u001b[0m\u001b[1;32m    411\u001b[0m                     \u001b[0mvalue\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmessage\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"Check if pdf output contains any NaNs of Infs\"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    412\u001b[0m                 )\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/z/wrapping_tf.py\u001b[0m in \u001b[0;36mcheck_numerics\u001b[0;34m(tensor, message, name)\u001b[0m\n\u001b[1;32m     92\u001b[0m         \u001b[0mcheck_op\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtf\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgroup\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mreal_check\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mimag_check\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     93\u001b[0m     \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 94\u001b[0;31m         check_op = tf.debugging.check_numerics(\n\u001b[0m\u001b[1;32m     95\u001b[0m             \u001b[0mtensor\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtensor\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmessage\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mmessage\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     96\u001b[0m         )\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/tensorflow/python/ops/gen_array_ops.py\u001b[0m in \u001b[0;36mcheck_numerics\u001b[0;34m(tensor, message, name)\u001b[0m\n\u001b[1;32m    964\u001b[0m       \u001b[0;32mreturn\u001b[0m \u001b[0m_result\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    965\u001b[0m     \u001b[0;32mexcept\u001b[0m \u001b[0m_core\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_NotOkStatusException\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 966\u001b[0;31m       \u001b[0m_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mraise_from_not_ok_status\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0me\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    967\u001b[0m     \u001b[0;32mexcept\u001b[0m \u001b[0m_core\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_FallbackException\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    968\u001b[0m       \u001b[0;32mpass\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/tensorflow/python/framework/ops.py\u001b[0m in \u001b[0;36mraise_from_not_ok_status\u001b[0;34m(e, name)\u001b[0m\n\u001b[1;32m   6654\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mraise_from_not_ok_status\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0me\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   6655\u001b[0m   \u001b[0me\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmessage\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m\" name: \"\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mname\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0mname\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;32melse\u001b[0m \u001b[0;34m\"\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 6656\u001b[0;31m   \u001b[0;32mraise\u001b[0m \u001b[0mcore\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_status_to_exception\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0me\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0;32mNone\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   6657\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   6658\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mInvalidArgumentError\u001b[0m: {{function_node __wrapped__CheckNumerics_device_/job:localhost/replica:0/task:0/device:CPU:0}} Check if pdf output contains any NaNs of Infs : Tensor had NaN values [Op:CheckNumerics] name: "
     ]
    }
   ],
   "source": [
    "import zfit\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.stats import norm\n",
    "import uproot\n",
    "import time  # To add a timestamp for uniqueness\n",
    "\n",
    "# Define ROOT file path\n",
    "root_file_path = \"mass_regionEE.root\"\n",
    "\n",
    "# Open the ROOT file and extract the histogram\n",
    "with uproot.open(root_file_path) as file:\n",
    "    hist = file[\"h_mass_2idpass_EE_hist1;1\"]\n",
    "    hist_values, hist_edges = hist.to_numpy()\n",
    "\n",
    "# Define the number of bins (if you want to reduce the number of bins, adjust this)\n",
    "num_bins_x = 120  # Reduced number of bins\n",
    "\n",
    "# Adjust binning\n",
    "binning = zfit.binned.VariableBinning(hist_edges, name=\"x\")  # 'x' to match the observable's name\n",
    "obs = zfit.Space(\"x\", limits=(hist_edges[0], hist_edges[-1]), binning=binning)\n",
    "\n",
    "# Define categories and signal fractions\n",
    "signal_fraction = {\n",
    "    \"ID_pass\": 0.98\n",
    "}\n",
    "categories = [\"ID_pass\"]\n",
    "\n",
    "# Create BinnedData objects for each category\n",
    "data_dict = {\n",
    "    category: zfit.data.BinnedData.from_tensor(space=obs, values=hist_values)\n",
    "    for category in categories\n",
    "}\n",
    "\n",
    "# Global set to track used parameter names to avoid conflicts\n",
    "used_names = set()\n",
    "\n",
    "# Function to generate a unique parameter name using timestamp\n",
    "def generate_unique_name(base_name):\n",
    "    timestamp = int(time.time() * 1000)  # Get current time in milliseconds\n",
    "    unique_name = f\"{base_name}_{timestamp}\"\n",
    "    while unique_name in used_names:\n",
    "        timestamp += 1  # Increment timestamp until we find a unique one\n",
    "        unique_name = f\"{base_name}_{timestamp}\"\n",
    "    used_names.add(unique_name)\n",
    "    return unique_name\n",
    "\n",
    "# Define the Breit-Wigner function\n",
    "class BreitWignerPDF(zfit.pdf.ZPDF):\n",
    "    _PARAMS = ['M', 'Gamma']\n",
    "\n",
    "    def _unnormalized_pdf(self, x):\n",
    "        M = self.params['M']  # Resonance mass\n",
    "        Gamma = self.params['Gamma']  # Width\n",
    "        x = zfit.z.unstack_x(x)  # Extract the independent variable\n",
    "        numerator = Gamma / 2\n",
    "        denominator = (x - M)**2 + (Gamma / 2)**2\n",
    "        return numerator / denominator\n",
    "\n",
    "# Define models for each category\n",
    "models = {}\n",
    "results = {}\n",
    "\n",
    "for category in categories:\n",
    "    # Generate unique names for the parameters\n",
    "    M_name = generate_unique_name(f\"M_{category}\")\n",
    "    Gamma_name = generate_unique_name(f\"Gamma_{category}\")\n",
    "    mu_kernel_name = generate_unique_name(f\"mu_kernel_{category}\")\n",
    "    sigma_kernel_name = generate_unique_name(f\"sigma_kernel_{category}\")\n",
    "    \n",
    "    # Create parameters with unique names\n",
    "    M = zfit.Parameter(M_name, 90.0, 80.0, 100.0)  # Mean resonance mass\n",
    "    Gamma = zfit.Parameter(Gamma_name, 2.5, 0.1, 10.0)  # Width\n",
    "    \n",
    "    # Signal model (Breit-Wigner)\n",
    "    signal_model = BreitWignerPDF(obs=obs, M=M, Gamma=Gamma)\n",
    "\n",
    "    # Define Gaussian kernel parameters for convolution\n",
    "    mu = zfit.Parameter(mu_kernel_name, 0.0, -5.0, 5.0)\n",
    "    sigma = zfit.Parameter(sigma_kernel_name, 1.0, 0.1, 5.0)\n",
    "    gaussian_kernel = zfit.pdf.Gauss(mu=mu, sigma=sigma, obs=obs)\n",
    "    \n",
    "    # Use FFTConvolution to convolve the Breit-Wigner signal with the Gaussian kernel\n",
    "    signal_model = BreitWignerPDF(obs=obs, M=M, Gamma=Gamma)\n",
    "    \n",
    "    signal_convolved = zfit.pdf.FFTConvPDFV1(func=signal_model, kernel=gaussian_kernel)\n",
    " \n",
    "    x = np.linspace(0, 1000, num=10000)\n",
    "    \n",
    "    y = signal_convolved.pdf(x)\n",
    "    \n",
    "    \n",
    "\n",
    "# # The histogram data\n",
    "# x_data = (hist_edges[:-1] + hist_edges[1:]) / 2  # Bin centers\n",
    "# y_data = hist_values  # Bin contents\n",
    "# print(signal_convolved)\n",
    "\n",
    "# # --- Plotting signal_convolved ---\n",
    "# # Create a grid of points over the observable range\n",
    "# x_values = np.linspace(hist_edges[0], hist_edges[-1], 1000)  # 1000 points for smoothness\n",
    "\n",
    "# # Set the parameters with their initial values\n",
    "# parameter_values = {\n",
    "#     M.name: M.value,  # Initial value for M\n",
    "#     Gamma.name: Gamma.value,  # Initial value for Gamma\n",
    "#     mu.name: mu.value,  # Initial value for mu\n",
    "#     sigma.name: sigma.value  # Initial value for sigma\n",
    "# }\n",
    "\n",
    "# # Evaluate the convolved signal PDF on the grid\n",
    "# with zfit.param.set_values(parameter_values):  # Pass the dictionary of parameter values\n",
    "#     y_values = signal_convolved.pdf(x_values).numpy()\n",
    "\n",
    "# # Plot the signal_convolved PDF\n",
    "# plt.figure(figsize=(10, 6))\n",
    "# plt.plot(x_values, y_values, label=\"Convolved Signal PDF\", color='blue')\n",
    "# plt.xlabel(\"x (observable)\")\n",
    "# plt.ylabel(\"PDF\")\n",
    "# plt.title(\"Convolved Signal (Breit-Wigner and Gaussian Kernel)\")\n",
    "# plt.legend()\n",
    "# plt.grid()\n",
    "# plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "1bf919cd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Breit-Wigner PDF values: [0.00212706 0.00213614 0.00214528 0.00215448 0.00216374 0.00217306\n",
      " 0.00218244 0.00219187 0.00220137 0.00221093]\n",
      "Error with Gaussian kernel: {{function_node __wrapped__CheckNumerics_device_/job:localhost/replica:0/task:0/device:CPU:0}} Check if pdf output contains any NaNs of Infs : Tensor had NaN values [Op:CheckNumerics] name: \n",
      "Error with convolution: {{function_node __wrapped__CheckNumerics_device_/job:localhost/replica:0/task:0/device:CPU:0}} Check if pdf output contains any NaNs of Infs : Tensor had NaN values [Op:CheckNumerics] name: \n"
     ]
    }
   ],
   "source": [
    "import zfit\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.stats import norm\n",
    "import uproot\n",
    "import time  # For timestamp-based unique names\n",
    "\n",
    "# Define ROOT file path\n",
    "root_file_path = \"mass_regionEE.root\"\n",
    "\n",
    "# Open the ROOT file and extract the histogram\n",
    "with uproot.open(root_file_path) as file:\n",
    "    hist = file[\"h_mass_2idpass_EE_hist1;1\"]\n",
    "    hist_values, hist_edges = hist.to_numpy()\n",
    "\n",
    "# Define the number of bins (if you want to reduce the number of bins, adjust this)\n",
    "num_bins_x = 120  # Reduced number of bins\n",
    "\n",
    "# Adjust binning\n",
    "binning = zfit.binned.VariableBinning(hist_edges, name=\"x\")  # 'x' to match the observable's name\n",
    "obs = zfit.Space(\"x\", limits=(hist_edges[0], hist_edges[-1]), binning=binning)\n",
    "\n",
    "# Define categories and signal fractions\n",
    "signal_fraction = {\n",
    "    \"ID_pass\": 0.98\n",
    "}\n",
    "categories = [\"ID_pass\"]\n",
    "\n",
    "# Create BinnedData objects for each category\n",
    "data_dict = {\n",
    "    category: zfit.data.BinnedData.from_tensor(space=obs, values=hist_values)\n",
    "    for category in categories\n",
    "}\n",
    "\n",
    "# Global set to track used parameter names to avoid conflicts\n",
    "used_names = set()\n",
    "\n",
    "# Function to generate a unique parameter name using timestamp\n",
    "def generate_unique_name(base_name):\n",
    "    timestamp = int(time.time() * 1000)  # Get current time in milliseconds\n",
    "    unique_name = f\"{base_name}_{timestamp}\"\n",
    "    while unique_name in used_names:\n",
    "        timestamp += 1  # Increment timestamp until we find a unique one\n",
    "        unique_name = f\"{base_name}_{timestamp}\"\n",
    "    used_names.add(unique_name)\n",
    "    return unique_name\n",
    "\n",
    "# Define the Breit-Wigner function\n",
    "class BreitWignerPDF(zfit.pdf.ZPDF):\n",
    "    _PARAMS = ['M', 'Gamma']\n",
    "\n",
    "    def _unnormalized_pdf(self, x):\n",
    "        M = self.params['M']  # Resonance mass\n",
    "        Gamma = self.params['Gamma']  # Width\n",
    "        x = zfit.z.unstack_x(x)  # Extract the independent variable\n",
    "        numerator = Gamma / 2\n",
    "        denominator = (x - M)**2 + (Gamma / 2)**2\n",
    "        return numerator / denominator\n",
    "\n",
    "# Define models for each category\n",
    "models = {}\n",
    "results = {}\n",
    "\n",
    "for category in categories:\n",
    "    # Generate unique names for the parameters\n",
    "    M_name = generate_unique_name(f\"M_{category}\")\n",
    "    Gamma_name = generate_unique_name(f\"Gamma_{category}\")\n",
    "    mu_kernel_name = generate_unique_name(f\"mu_kernel_{category}\")\n",
    "    sigma_kernel_name = generate_unique_name(f\"sigma_kernel_{category}\")\n",
    "    \n",
    "    # Create parameters with unique names\n",
    "    M = zfit.Parameter(M_name, 90.0, 80.0, 100.0)  # Mean resonance mass\n",
    "    Gamma = zfit.Parameter(Gamma_name, 2.5, 0.1, 10.0)  # Width\n",
    "    \n",
    "    # Signal model (Breit-Wigner)\n",
    "    signal_model = BreitWignerPDF(obs=obs, M=M, Gamma=Gamma)\n",
    "\n",
    "    # Define Gaussian kernel parameters for convolution\n",
    "    mu = zfit.Parameter(mu_kernel_name, 0.0, -5.0, 5.0)\n",
    "    sigma = zfit.Parameter(sigma_kernel_name, 2.0, 0.1, 5.0)  # Increased sigma to improve stability\n",
    "    gaussian_kernel = zfit.pdf.Gauss(mu=mu, sigma=sigma, obs=obs)\n",
    "\n",
    "# --- Debugging: Check individual PDFs before convolution ---\n",
    "# Create a grid of points over the observable range\n",
    "x_values = np.linspace(hist_edges[0], hist_edges[-1], 1000)  # 1000 points for smoothness\n",
    "\n",
    "# Set the parameter values directly\n",
    "M.set_value(90.0)    # Initial value for M\n",
    "Gamma.set_value(2.5) # Initial value for Gamma\n",
    "mu.set_value(0.0)    # Initial value for mu (Gaussian kernel)\n",
    "sigma.set_value(2.0) # Increased value for sigma (Gaussian kernel)\n",
    "\n",
    "# Check the Breit-Wigner PDF before convolution\n",
    "bw_values = signal_model.pdf(x_values).numpy()\n",
    "print(\"Breit-Wigner PDF values:\", bw_values[:10])  # Print first 10 values\n",
    "\n",
    "# --- Debugging: Check Gaussian kernel separately ---\n",
    "try:\n",
    "    # Check the Gaussian kernel PDF separately\n",
    "    gaussian_values = gaussian_kernel.pdf(x_values).numpy()\n",
    "    if np.any(np.isnan(gaussian_values)) or np.any(np.isinf(gaussian_values)):\n",
    "        print(\"Warning: Gaussian kernel produced NaNs or Infs!\")\n",
    "    else:\n",
    "        print(\"Gaussian Kernel PDF values:\", gaussian_values[:10])  # Print first 10 values\n",
    "except Exception as e:\n",
    "    print(f\"Error with Gaussian kernel: {e}\")\n",
    "\n",
    "# --- Checking if the convolution introduces instability ---\n",
    "# Now evaluate the convolved signal PDF on the grid\n",
    "try:\n",
    "    y_values = signal_convolved.pdf(x_values).numpy()\n",
    "\n",
    "    # Check if the output contains NaNs or Infs\n",
    "    if np.any(np.isnan(y_values)) or np.any(np.isinf(y_values)):\n",
    "        print(\"Warning: Convolution result contains NaNs or Infs!\")\n",
    "    else:\n",
    "        # Plot the signal_convolved PDF\n",
    "        plt.figure(figsize=(10, 6))\n",
    "        plt.plot(x_values, y_values, label=\"Convolved Signal PDF\", color='blue')\n",
    "        plt.xlabel(\"x (observable)\")\n",
    "        plt.ylabel(\"PDF\")\n",
    "        plt.title(\"Convolved Signal (Breit-Wigner and Gaussian Kernel)\")\n",
    "        plt.legend()\n",
    "        plt.grid()\n",
    "        plt.show()\n",
    "except Exception as e:\n",
    "    print(f\"Error with convolution: {e}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "6dd08f3a",
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "import uproot\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "root_file_path = \"mass_regionEE.root\"\n",
    "\n",
    "# Open the ROOT file and extract the histogram\n",
    "with uproot.open(root_file_path) as file:\n",
    "    hist = file[\"h_mass_2idpass_EE_hist1;1\"]\n",
    "    hist_values, hist_edges = hist.to_numpy()\n",
    "\n",
    "# The histogram data\n",
    "x_data = (hist_edges[:-1] + hist_edges[1:]) / 2  # Bin centers\n",
    "y_data = hist_values  # Bin contents\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8ea4a049",
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "import zfit\n",
    "import numpy as np\n",
    "import uproot\n",
    "import matplotlib.pyplot as plt\n",
    "import tensorflow as tf\n",
    "\n",
    "# Load the data from the ROOT file\n",
    "root_file_path = \"mass_regionEE.root\"\n",
    "with uproot.open(root_file_path) as file:\n",
    "    hist = file[\"h_mass_2idpass_EE_hist1;1\"]\n",
    "    hist_values, hist_edges = hist.to_numpy()\n",
    "\n",
    "# Define the zfit observable (space for mass)\n",
    "obs = zfit.Space(\"mass\", limits=(hist_edges[0], hist_edges[-1]))\n",
    "\n",
    "# Parameters for the Breit-Wigner distribution (signal)\n",
    "M = 91.1876  # Z boson mass in GeV\n",
    "Gamma = 2.495  # Z boson width in GeV\n",
    "\n",
    "# Step 1: Define the Breit-Wigner PDF model\n",
    "class BreitWignerPDF(zfit.pdf.BasePDF):\n",
    "    def __init__(self, obs, M, Gamma):\n",
    "        self.M = M\n",
    "        self.Gamma = Gamma\n",
    "        super().__init__(obs=obs)\n",
    "\n",
    "    def _unnormalized_pdf(self, x):\n",
    "    # Extract the numpy array from the zfit.Data object\n",
    "        x_values = x.numpy()  # This will get the raw values in a numpy array\n",
    "    \n",
    "    # Now, use TensorFlow operations on the numpy array\n",
    "        x_minus_M = tf.subtract(x_values, self.M)  # Subtraction using TensorFlow\n",
    "        bw = (1 / (np.pi * self.Gamma)) * (self.Gamma**2 / (tf.square(x_minus_M) + self.Gamma**2))\n",
    "    \n",
    "        return bw\n",
    "\n",
    "# Create the Breit-Wigner PDF model\n",
    "bw_model = BreitWignerPDF(obs=obs, M=M, Gamma=Gamma)\n",
    "\n",
    "# Step 2: Define the Gaussian kernel for convolution\n",
    "class GaussianKernel(zfit.pdf.BasePDF):\n",
    "    def __init__(self, obs, mu, sigma):\n",
    "        self.mu = mu\n",
    "        self.sigma = sigma\n",
    "        super().__init__(obs=obs)\n",
    "\n",
    "    def _unnormalized_pdf(self, x):\n",
    "        # Gaussian formula with TensorFlow operations\n",
    "        gauss = (1 / (self.sigma * tf.sqrt(2 * np.pi))) * tf.exp(-0.5 * tf.square((x - self.mu) / self.sigma))\n",
    "        return gauss\n",
    "\n",
    "# Parameters for the Gaussian kernel (e.g., for smoothing)\n",
    "sigma = 1.0  # Standard deviation of the Gaussian\n",
    "mu = 0.0  # Mean of the Gaussian\n",
    "\n",
    "# Create the Gaussian kernel PDF\n",
    "gaussian_kernel = GaussianKernel(obs=obs, mu=mu, sigma=sigma)\n",
    "\n",
    "# Step 3: Perform the FFT-based convolution\n",
    "signal_convoluted = zfit.pdf.FFTConvPDFV1(func=bw_model, kernel=gaussian_kernel)\n",
    "\n",
    "\n",
    "# # Step 4: Evaluate the convolved signal\n",
    "# x_values = np.linspace(hist_edges[0], hist_edges[-1], 1000)\n",
    "# signal_values = signal_convoluted.pdf(x_values)\n",
    "\n",
    "# Create a Data object using zfit with the x_values\n",
    "\n",
    "# # Step 5: Plot the results\n",
    "# plt.figure(figsize=(10, 6))\n",
    "x_values = np.linspace(hist_edges[0], hist_edges[-1], 1000).astype(np.float32)  # Cast to float32\n",
    "x_data = zfit.data.Data.from_numpy(obs=obs, array=x_values)\n",
    "\n",
    "# Now, evaluate the PDF with the Data object\n",
    "signal_values = signal_convoluted.pdf(x_data)\n",
    "# # Plot the convoluted signal\n",
    "# plt.plot(x_values, signal_values, label=\"Convolved Signal\", color=\"red\", linewidth=2)\n",
    "\n",
    "# # Plot the histogram data\n",
    "# plt.hist(hist_values, bins=hist_edges, histtype='step', label=\"Histogram Data\", density=True)\n",
    "\n",
    "# plt.legend()\n",
    "# plt.xlabel(\"Mass (GeV)\")\n",
    "# plt.ylabel(\"Probability Density\")\n",
    "# plt.title(\"Signal Convolution with Gaussian Kernel (using zfit)\")\n",
    "# plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "91cee652",
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "data": {
      "image/png": "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EhHxl5n9L5DnnOvqbHoR6SfV4EXEF2Y22cxmBgbgmY93SWRPl1eKSD/oLEgR8Us6XrP8aLxBfn4I/NPXiEQiiJroRUREIpCa6EVERCKQEryIiEgEiqg++OHDh7sJEyYM2Pbq6upITU0dsO35KVLKEinlAJUlXEVKWSKlHKCy9GT16tUVzrkRXc2LqAQ/YcIEVq1aNWDbW7ZsGYsXLx6w7fkpUsoSKeUAlSVcRUpZIqUcoLL0xMze6W6emuhFREQikBK8iIhIBFKCFxERiUAR1QcvIhKNmpubKSsro6GhoWNaZmYmmzdv9jGqgaOyQFJSEmPHjiU+Pr7P6yjBi4gMcWVlZaSnpzNhwgS8u9dCTU0N6enpPkc2MKK9LM45KisrKSsro6CgoM/rqYleRGSIa2hoICcnpyO5S2QxM3Jyco5poekLJXgRkQig5B7ZTuT4KsGLiMhJ279/P9deey1FRUVMnTqVSy+9lLfffntQ9j1hwgQqKipOejv33HMPP/jBD46bvnXrVhYvXszs2bOZMmUKt956KwCrVq3i05/+9Envt69x9Jf64EVE5KQ457jyyiu58cYbeeihhwAoLi7mwIEDTJo0yefoTt6nP/1pPve5z3H55ZcDsH79egDmzZvHvHnz/AytR6rBi0i/7K06yoNv7j7msay0ueP5sxv20damu1RGk3//+9/Ex8dz++23d0ybPXs2Z599Ns45vvCFLzB9+nRmzJjBww8/DLw7otvVV1/N5MmTuf7663HO8cwzz3DNNdd0bGfZsmUdrx988EFmzJjB9OnTufPOO4+L48477+QXv/hFx+t77rmHH/7whwB8//vf5/TTT2fmzJncfffdHct861vf4tRTT+WCCy5g69atXZZv3759jB07tuP1jBkzOmK77LLLACgvL+fCCy9k7ty53HbbbYwfP56Kigp27drFlClTuOWWW5g2bRqXX345R48eBeD+++/n9NNPZ9asWXzgAx+gvr6+H+9675TgRaTPKmsbufqXy/nio+uPefxuY1PH89v/9Bb/98LgNM1KeNiwYQOnnXZal/MeffRRiouLWbt2LS+88AJf+MIX2LdvHwBr1qzhxz/+MZs2baKkpITXXnuNCy+8kNdff526ujoAHn74Ya666ir27t3LnXfeyYsvvkhxcTErV67kH//4xzH7uvbaazt+QAA88sgjfPCDH2Tp0qVs27aNN998k+LiYlavXs3LL7/M6tWreeihh1izZg2PPvooK1eu7LIMn/vc5zj//PNZsmQJ//d//0dVVdVxy3z961/n/PPP56233uLKK69k9+7dHfO2bdvGpz71KTZu3EhWVhZ///vfAbjqqqtYuXIla9euZcqUKfzmN7/p83veF2qiF5E++8m/tlFe28iDt5xBwfB3b5ixYsVyFi48E4DvPbeFn/17O1efNpbxOZFxg5Ch5OtPbGTT3mpaW1uJjY0dkG1OHZ3B3e+bdkLrvvrqq1x33XXExsaSm5vLueeey8qVK8nIyGD+/PkdNePZs2eza9cuFi1axCWXXMITTzzB1VdfzVNPPcVXv/pVVq5cyeLFixkxwruvyvXXX8/LL7/MFVdc0bGvOXPmcPDgQfbu3Ut5eTnZ2dmMGzeOn/70pyxdupQ5c+YAUFtby7Zt26ipqeHKK68kJSUFgPe///1dluFjH/sYF198Mc8++yz//Oc/+dWvfsXatWuPK+djjz0GwCWXXEJ2dnbHvIKCAmbPnn1MOcH7YfSVr3yFqqoqamtrufjii0/oPe6OavAi0idV9U38dVUZl88ew8KiHPIykzoe2UkxHc/vvGQycTHGb1/b5XfIMkimTZvG6tWru5znXPfdNYmJiR3PY2NjaWlpAeBDH/oQjzzyCC+++CKnn3466enpPW4n2NVXX83f/vY3Hn74Ya699tqOGL74xS9SXFxMcXEx27dv5+abbwb6fnb66NGj+fjHP84///lP4uLi2LBhw0mX86abbuJnP/sZ69ev5+677+73ZXC9UQ1eRPrkL2/u5mhzKzcv6nmgjdyMJN43azSPrCrlcxdMIjOl7yNvyclrr2kP5uAw559/Pl/60pe4//77ueWWWwBYuXIl9fX1nHPOOfzqV7/ixhtv5NChQ7z88st8//vfZ8uWLd1ub/Hixdx8883cf//9fOhDHwJgwYIFfOYzn6GiooLs7GwefPBB/vM///O4da+99lpuueUWKioqeOmllwC4+OKL+epXv8r1119PWloae/bsIT4+nnPOOYebbrqJu+66i5aWFp544gluu+2247b57LPP8p73vIf4+Hj2799PZWUlY8aMOaYMixYt4pFHHuHOO+9k6dKlHD58uNf3raamhlGjRtHc3Myf//xnxowZ0+s6/aEavIj0qqmljd8v38Wi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\n",
      "text/plain": [
       "<Figure size 576x360 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import tensorflow as tf\n",
    "import zfit\n",
    "import uuid  # To generate unique parameter names\n",
    "\n",
    "# Enable eager execution\n",
    "tf.config.experimental_run_functions_eagerly(True)\n",
    "\n",
    "# Define the observable\n",
    "obs = zfit.Space(\"x\", limits=(-10, 10))  # Adjust the limits as appropriate\n",
    "\n",
    "# Generate unique names for parameters\n",
    "unique_id = uuid.uuid4().hex[:8]  # Short unique identifier\n",
    "\n",
    "# Parameters for the Gaussian kernel\n",
    "mu_gaussian = zfit.Parameter(f\"mu_gaussian_{unique_id}\", 0.0)  # Unique name for Gaussian mean\n",
    "sigma_gaussian = zfit.Parameter(f\"sigma_gaussian_{unique_id}\", 1.0)  # Unique name for Gaussian std dev\n",
    "\n",
    "# Parameters for the Breit-Wigner\n",
    "M_bw = zfit.Parameter(f\"M_bw_{unique_id}\", 0.0)  # Unique name for Breit-Wigner mass\n",
    "Gamma_bw = zfit.Parameter(f\"Gamma_bw_{unique_id}\", 2.0)  # Unique name for Breit-Wigner width\n",
    "\n",
    "# Custom Breit-Wigner PDF\n",
    "class BreitWignerPDF(zfit.pdf.BasePDF):\n",
    "    def _unnormalized_pdf(self, x):\n",
    "        # Convert x to tensor\n",
    "        x_tensor = x.value()  # Extract the tensor value from zfit.Data\n",
    "        M_val = tf.convert_to_tensor(zfit.run(M_bw), dtype=tf.float64)\n",
    "        Gamma_val = tf.convert_to_tensor(zfit.run(Gamma_bw), dtype=tf.float64)\n",
    "        return 1 / ((x_tensor - M_val) ** 2 + (Gamma_val / 2) ** 2)\n",
    "\n",
    "# Instantiate the Breit-Wigner PDF\n",
    "signal_model = BreitWignerPDF(obs=obs)\n",
    "\n",
    "# Create the Gaussian kernel and the convolved signal\n",
    "gaussian_kernel = zfit.pdf.Gauss(mu=mu_gaussian, sigma=sigma_gaussian, obs=obs)\n",
    "signal_convolved = zfit.pdf.FFTConvPDFV1(func=signal_model, kernel=gaussian_kernel)\n",
    "\n",
    "# Generate x values\n",
    "x_values = np.linspace(-10, 10, 500)  # Adjust range and resolution as needed\n",
    "\n",
    "# Evaluate the convolved signal at the x values\n",
    "x_tensor = tf.convert_to_tensor(x_values, dtype=tf.float64)  # Convert to tensor for evaluation\n",
    "signal_convolved_values = signal_convolved.pdf(x_tensor).numpy()  # Ensure eager execution for .numpy()\n",
    "\n",
    "# Plot the result\n",
    "plt.figure(figsize=(8, 5))\n",
    "plt.plot(x_values, signal_convolved_values, label=\"Convolved Signal\")\n",
    "plt.title(\"Convolution of Breit-Wigner and Gaussian\")\n",
    "plt.xlabel(\"x\")\n",
    "plt.ylabel(\"PDF\")\n",
    "plt.legend()\n",
    "plt.grid()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "668962fa",
   "metadata": {},
   "outputs": [
    {
     "ename": "InvalidArgumentError",
     "evalue": "{{function_node __wrapped__CheckNumerics_device_/job:localhost/replica:0/task:0/device:CPU:0}} Check if pdf output contains any NaNs of Infs : Tensor had NaN values [Op:CheckNumerics] name: ",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mInvalidArgumentError\u001b[0m                      Traceback (most recent call last)",
      "\u001b[0;32m/tmp/ipykernel_440/4093782672.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     61\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     62\u001b[0m \u001b[0msignal_model_values\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0msignal_model\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpdf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx_tensor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnumpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 63\u001b[0;31m \u001b[0mgaussian_kernel_values\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mgaussian_kernel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpdf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx_tensor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnumpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     64\u001b[0m \u001b[0msignal_convolved_values\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0msignal_convolved\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpdf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx_tensor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnumpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     65\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/tensorflow/python/util/deprecation.py\u001b[0m in \u001b[0;36mnew_func\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m    574\u001b[0m                 \u001b[0;34m'in a future version'\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0mdate\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;32melse\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m'after %s'\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mdate\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    575\u001b[0m                 instructions)\n\u001b[0;32m--> 576\u001b[0;31m       \u001b[0;32mreturn\u001b[0m \u001b[0mfunc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    577\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    578\u001b[0m     doc = _add_deprecated_arg_notice_to_docstring(\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/util/deprecation.py\u001b[0m in \u001b[0;36mwrapper\u001b[0;34m(norm, norm_range, *args, **kwargs)\u001b[0m\n\u001b[1;32m     14\u001b[0m             \u001b[0mnorm\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnorm_range\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     15\u001b[0m         \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 16\u001b[0;31m             \u001b[0;32mreturn\u001b[0m \u001b[0mfunc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnorm\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mnorm\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     17\u001b[0m         \u001b[0;32mexcept\u001b[0m \u001b[0mTypeError\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0merror\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     18\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0;34m\"unexpected keyword argument 'norm'\"\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0merror\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/z/zextension.py\u001b[0m in \u001b[0;36mconcrete_func\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m    245\u001b[0m         \u001b[0;32mdef\u001b[0m \u001b[0mconcrete_func\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    246\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdo_jit\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0mfunc\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcurrently_traced\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 247\u001b[0;31m                 \u001b[0;32mreturn\u001b[0m \u001b[0mfunc\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    248\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    249\u001b[0m             \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcurrently_traced\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0madd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfunc\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/core/basepdf.py\u001b[0m in \u001b[0;36mpdf\u001b[0;34m(***failed resolving arguments***)\u001b[0m\n\u001b[1;32m    408\u001b[0m             \u001b[0mvalue\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_single_hook_pdf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnorm\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mnorm\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    409\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mrun\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnumeric_checks\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 410\u001b[0;31m                 z.check_numerics(\n\u001b[0m\u001b[1;32m    411\u001b[0m                     \u001b[0mvalue\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmessage\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"Check if pdf output contains any NaNs of Infs\"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    412\u001b[0m                 )\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/zfit/z/wrapping_tf.py\u001b[0m in \u001b[0;36mcheck_numerics\u001b[0;34m(tensor, message, name)\u001b[0m\n\u001b[1;32m     92\u001b[0m         \u001b[0mcheck_op\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtf\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgroup\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mreal_check\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mimag_check\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     93\u001b[0m     \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 94\u001b[0;31m         check_op = tf.debugging.check_numerics(\n\u001b[0m\u001b[1;32m     95\u001b[0m             \u001b[0mtensor\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtensor\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmessage\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mmessage\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     96\u001b[0m         )\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/tensorflow/python/ops/gen_array_ops.py\u001b[0m in \u001b[0;36mcheck_numerics\u001b[0;34m(tensor, message, name)\u001b[0m\n\u001b[1;32m    964\u001b[0m       \u001b[0;32mreturn\u001b[0m \u001b[0m_result\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    965\u001b[0m     \u001b[0;32mexcept\u001b[0m \u001b[0m_core\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_NotOkStatusException\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 966\u001b[0;31m       \u001b[0m_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mraise_from_not_ok_status\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0me\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    967\u001b[0m     \u001b[0;32mexcept\u001b[0m \u001b[0m_core\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_FallbackException\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    968\u001b[0m       \u001b[0;32mpass\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/tensorflow/python/framework/ops.py\u001b[0m in \u001b[0;36mraise_from_not_ok_status\u001b[0;34m(e, name)\u001b[0m\n\u001b[1;32m   6654\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mraise_from_not_ok_status\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0me\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   6655\u001b[0m   \u001b[0me\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmessage\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m\" name: \"\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mname\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0mname\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;32melse\u001b[0m \u001b[0;34m\"\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 6656\u001b[0;31m   \u001b[0;32mraise\u001b[0m \u001b[0mcore\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_status_to_exception\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0me\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0;32mNone\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   6657\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   6658\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mInvalidArgumentError\u001b[0m: {{function_node __wrapped__CheckNumerics_device_/job:localhost/replica:0/task:0/device:CPU:0}} Check if pdf output contains any NaNs of Infs : Tensor had NaN values [Op:CheckNumerics] name: "
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import tensorflow as tf\n",
    "import zfit\n",
    "import uuid  # To generate unique parameter names\n",
    "\n",
    "# Enable eager execution\n",
    "tf.config.experimental_run_functions_eagerly(True)\n",
    "\n",
    "# Define the observable\n",
    "obs = zfit.Space(\"x\", limits=(76, 106))  # Adjust the limits as appropriate\n",
    "\n",
    "# Generate unique names for parameters\n",
    "unique_id = uuid.uuid4().hex[:8]  # Short unique identifier\n",
    "\n",
    "# Parameters for the Gaussian kernel\n",
    "mu_gaussian = zfit.Parameter(f\"mu_gaussian_{unique_id}\", 0.0)  # Unique name for Gaussian mean\n",
    "sigma_gaussian = zfit.Parameter(f\"sigma_gaussian_{unique_id}\", 1.0)  # Unique name for Gaussian std dev\n",
    "\n",
    "# Parameters for the Breit-Wigner\n",
    "M_bw = zfit.Parameter(f\"M_bw_{unique_id}\", 0.0)  # Unique name for Breit-Wigner mass\n",
    "Gamma_bw = zfit.Parameter(f\"Gamma_bw_{unique_id}\", 2.0)  # Unique name for Breit-Wigner width\n",
    "\n",
    "# Custom Breit-Wigner PDF\n",
    "class BreitWignerPDF(zfit.pdf.BasePDF):\n",
    "    def _unnormalized_pdf(self, x):\n",
    "        # Convert x to tensor\n",
    "        x_tensor = x.value()  # Extract the tensor value from zfit.Data\n",
    "        M_val = tf.convert_to_tensor(zfit.run(M_bw), dtype=tf.float64)\n",
    "        Gamma_val = tf.convert_to_tensor(zfit.run(Gamma_bw), dtype=tf.float64)\n",
    "        return 1 / ((x_tensor - M_val) ** 2 + (Gamma_val / 2) ** 2)\n",
    "\n",
    "# Instantiate the Breit-Wigner PDF\n",
    "signal_model = BreitWignerPDF(obs=obs)\n",
    "gaussian_kernel = zfit.pdf.Gauss(mu=mu_gaussian, sigma=sigma_gaussian, obs=obs)\n",
    "\n",
    "signal_convolved = zfit.pdf.FFTConvPDFV1(func=signal_model, kernel=gaussian_kernel)\n",
    "\n",
    "\n",
    "\n",
    "# Provided histogram values and edges\n",
    "hist_values = np.array([\n",
    "    9, 7, 11, 2, 9, 10, 10, 8, 6, 11, 8, 12, 11, 11, 18, 14, 8, 17, 10, 13,\n",
    "    14, 24, 23, 19, 19, 34, 28, 24, 27, 29, 27, 42, 29, 41, 43, 45, 40, 56,\n",
    "    66, 53, 78, 84, 80, 115, 129, 123, 142, 156, 185, 189, 225, 241, 252, 281,\n",
    "    297, 319, 334, 363, 405, 412, 396, 351, 340, 370, 320, 258, 269, 238, 188,\n",
    "    174, 147, 116, 107, 93, 87, 87, 59, 59, 57, 50, 41, 35, 38, 41, 24, 29,\n",
    "    26, 27, 21, 16, 17, 14, 12, 15, 13, 13, 12, 14, 14, 11, 7, 11, 9, 22, 16,\n",
    "    11, 6, 6, 13, 2, 5, 6, 6, 6, 6, 4, 6, 3, 6, 5\n",
    "])\n",
    "hist_edges = np.linspace(76, 106, len(hist_values) + 1)\n",
    "\n",
    "# Calculate the bin centers (mid-points of each bin)\n",
    "bin_centers = (hist_edges[:-1] + hist_edges[1:]) / 2\n",
    "\n",
    "# Convert bin centers to a TensorFlow tensor for evaluation\n",
    "x_tensor = tf.convert_to_tensor(bin_centers, dtype=tf.float64)  # Convert to tensor for evaluation\n",
    "\n",
    "# Evaluate the pure signal model (Breit-Wigner) at the bin centers\n",
    "\n",
    "\n",
    "signal_model_values = signal_model.pdf(x_tensor).numpy()\n",
    "gaussian_kernel_values = gaussian_kernel.pdf(x_tensor).numpy()\n",
    "signal_convolved_values = signal_convolved.pdf(x_tensor).numpy()\n",
    "\n",
    "# signal_model_values = signal_model.pdf(x_tensor)\n",
    "# signal_model_values = signal_model_values.numpy()  # Convert to numpy array for further use\n",
    "print(\"Breit-Wigner PDF values:\", signal_model_values)\n",
    "print(\"Gaussian Kernel values:\", gaussian_kernel_values)\n",
    "print(\"Convolved Signal values:\", signal_convolved_values)\n",
    "# Evaluate the Gaussian kernel at the bin centers\n",
    "# gaussian_kernel_values = gaussian_kernel.pdf(x_tensor)\n",
    "# gaussian_kernel_values = gaussian_kernel_values.numpy()  # Convert to numpy array for further use\n",
    "\n",
    "# Evaluate the convolved signal at the bin centers\n",
    "# signal_convolved_values = signal_convolved.pdf(x_tensor)\n",
    "# signal_convolved_values = signal_convolved_values.numpy()  # Convert to numpy array for further use\n",
    "\n",
    "# Plot the result\n",
    "plt.figure(figsize=(8, 5))\n",
    "plt.step(bin_centers, hist_values, label=\"Histogram\", where='mid', color='blue')  # Plot histogram as step plot\n",
    "plt.plot(bin_centers, signal_convolved_values, label=\"Convolved Signal\", color='red')  # Convolved signal\n",
    "# plt.plot(bin_centers, signal_model_values, label=\"Signal Model (Breit-Wigner)\", color='green', linestyle='--')  # Pure Breit-Wigner\n",
    "plt.title(\"Convolution of Breit-Wigner and Gaussian with Histogram\")\n",
    "plt.xlabel(\"x (bin centers)\")\n",
    "plt.ylabel(\"PDF / Histogram\")\n",
    "plt.legend()\n",
    "plt.grid()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "ca556347",
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tf.Tensor(\n",
      "[ 76.125  76.375  76.625  76.875  77.125  77.375  77.625  77.875  78.125\n",
      "  78.375  78.625  78.875  79.125  79.375  79.625  79.875  80.125  80.375\n",
      "  80.625  80.875  81.125  81.375  81.625  81.875  82.125  82.375  82.625\n",
      "  82.875  83.125  83.375  83.625  83.875  84.125  84.375  84.625  84.875\n",
      "  85.125  85.375  85.625  85.875  86.125  86.375  86.625  86.875  87.125\n",
      "  87.375  87.625  87.875  88.125  88.375  88.625  88.875  89.125  89.375\n",
      "  89.625  89.875  90.125  90.375  90.625  90.875  91.125  91.375  91.625\n",
      "  91.875  92.125  92.375  92.625  92.875  93.125  93.375  93.625  93.875\n",
      "  94.125  94.375  94.625  94.875  95.125  95.375  95.625  95.875  96.125\n",
      "  96.375  96.625  96.875  97.125  97.375  97.625  97.875  98.125  98.375\n",
      "  98.625  98.875  99.125  99.375  99.625  99.875 100.125 100.375 100.625\n",
      " 100.875 101.125 101.375 101.625 101.875 102.125 102.375 102.625 102.875\n",
      " 103.125 103.375 103.625 103.875 104.125 104.375 104.625 104.875 105.125\n",
      " 105.375 105.625 105.875], shape=(120,), dtype=float64)\n"
     ]
    },
    {
     "ename": "ValueError",
     "evalue": "volume and kernel should have the same dimensionality",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m/tmp/ipykernel_439/592185562.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     78\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     79\u001b[0m \u001b[0;31m# Perform convolution in the normal (non-FFT) space\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 80\u001b[0;31m     \u001b[0mconvolved_signal\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mconvolve\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msignal_model_values\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mgaussian_kernel_values\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmode\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'same'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     81\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     82\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/scipy/signal/_signaltools.py\u001b[0m in \u001b[0;36mconvolve\u001b[0;34m(in1, in2, mode, method)\u001b[0m\n\u001b[1;32m   1401\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0mvolume\u001b[0m \u001b[0;34m*\u001b[0m \u001b[0mkernel\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1402\u001b[0m     \u001b[0;32melif\u001b[0m \u001b[0mvolume\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mndim\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0mkernel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mndim\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1403\u001b[0;31m         raise ValueError(\"volume and kernel should have the same \"\n\u001b[0m\u001b[1;32m   1404\u001b[0m                          \"dimensionality\")\n\u001b[1;32m   1405\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mValueError\u001b[0m: volume and kernel should have the same dimensionality"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import tensorflow as tf\n",
    "import zfit\n",
    "import uuid  # To generate unique parameter names\n",
    "\n",
    "# Enable eager execution for TensorFlow\n",
    "tf.config.experimental_run_functions_eagerly(True)\n",
    "\n",
    "# Define the observable (adjust the limits as necessary for your use case)\n",
    "obs = zfit.Space(\"x\", limits=(75, 105))\n",
    "\n",
    "# Generate unique names for parameters to avoid conflicts\n",
    "unique_id = uuid.uuid4().hex[:8]  # Generate a short unique identifier\n",
    "\n",
    "# Parameters for the Gaussian kernel\n",
    "mu_gaussian = zfit.Parameter(f\"mu_gaussian_{unique_id}\", 90.0, lower=75.0, upper=105.0)\n",
    "sigma_gaussian = zfit.Parameter(f\"sigma_gaussian_{unique_id}\", 5.0, lower=0.1, upper=20.0)\n",
    "\n",
    "# Parameters for the Breit-Wigner\n",
    "M_bw = zfit.Parameter(f\"M_bw_{unique_id}\", 90.0, lower=75.0, upper=105.0)\n",
    "Gamma_bw = zfit.Parameter(f\"Gamma_bw_{unique_id}\", 2.0, lower=0.1, upper=10.0)\n",
    "\n",
    "# Custom Breit-Wigner PDF\n",
    "class BreitWignerPDF(zfit.pdf.BasePDF):\n",
    "    def _unnormalized_pdf(self, x):\n",
    "        x_tensor = x.value()  # Get tensor values\n",
    "        M_val = tf.convert_to_tensor(zfit.run(M_bw), dtype=tf.float64)\n",
    "        Gamma_val = tf.convert_to_tensor(zfit.run(Gamma_bw), dtype=tf.float64)\n",
    "        return 1 / ((x_tensor - M_val) ** 2 + (Gamma_val / 2) ** 2)\n",
    "\n",
    "# Instantiate the Breit-Wigner PDF\n",
    "signal_model = BreitWignerPDF(obs=obs)\n",
    "\n",
    "# Create the Gaussian kernel and the convolved signal\n",
    "gaussian_kernel = zfit.pdf.Gauss(mu=mu_gaussian, sigma=sigma_gaussian, obs=obs)\n",
    "\n",
    "# Convolve the Breit-Wigner with the Gaussian kernel\n",
    "# signal_convolved = zfit.pdf.FFTConvPDFV1(func=signal_model, kernel=gaussian_kernel)\n",
    "\n",
    "signal_convolved = zfit.pdf.FFTConvPDFV1(func=signal_model, kernel=gaussian_kernel)\n",
    "# Histogram values and edges (provided data)\n",
    "hist_values = np.array([\n",
    "    9, 7, 11, 2, 9, 10, 10, 8, 6, 11, 8, 12, 11, 11, 18, 14, 8, 17, 10, 13,\n",
    "    14, 24, 23, 19, 19, 34, 28, 24, 27, 29, 27, 42, 29, 41, 43, 45, 40, 56,\n",
    "    66, 53, 78, 84, 80, 115, 129, 123, 142, 156, 185, 189, 225, 241, 252, 281,\n",
    "    297, 319, 334, 363, 405, 412, 396, 351, 340, 370, 320, 258, 269, 238, 188,\n",
    "    174, 147, 116, 107, 93, 87, 87, 59, 59, 57, 50, 41, 35, 38, 41, 24, 29,\n",
    "    26, 27, 21, 16, 17, 14, 12, 15, 13, 13, 12, 14, 14, 11, 7, 11, 9, 22, 16,\n",
    "    11, 6, 6, 13, 2, 5, 6, 6, 6, 6, 4, 6, 3, 6, 5\n",
    "])\n",
    "hist_edges = np.linspace(76, 106, len(hist_values) + 1)\n",
    "\n",
    "# Calculate the bin centers (mid-points of each bin)\n",
    "bin_centers = (hist_edges[:-1] + hist_edges[1:]) / 2\n",
    "\n",
    "# Convert bin centers to TensorFlow tensor\n",
    "x_tensor = tf.convert_to_tensor(bin_centers, dtype=tf.float64)\n",
    "print(x_tensor)\n",
    "# Check for NaN or Inf issues during evaluation\n",
    "try:\n",
    "    # Evaluate the pure signal model (Breit-Wigner) at the bin centers\n",
    "    signal_model_values = signal_model.pdf(x_tensor)\n",
    "    signal_model_values = signal_model_values.numpy()  # Convert to numpy for plotting\n",
    "\n",
    "    # Evaluate the Gaussian kernel at the bin centers\n",
    "    gaussian_kernel_values = gaussian_kernel.pdf(x_tensor)\n",
    "    gaussian_kernel_values = gaussian_kernel_values.numpy()  # Convert to numpy for plotting\n",
    "\n",
    "    # Evaluate the convolved signal at the bin centers\n",
    "    \n",
    "    \n",
    "    signal_convolved_value = signal_convolved.pdf(x_tensor)\n",
    "    \n",
    "    signal_convolved_values = signal_convolved_value.numpy()  # Convert to numpy for plotting\n",
    "    \n",
    "    from scipy.signal import convolve\n",
    "\n",
    "# Perform convolution in the normal (non-FFT) space\n",
    "    convolved_signal = convolve(signal_model_values, gaussian_kernel_values, mode='same')\n",
    "\n",
    "\n",
    "except tf.errors.InvalidArgumentError as e:\n",
    "    print(\"Invalid Argument Error: Check if input data leads to NaNs or Infs. Error:\", e)\n",
    "    raise\n",
    "\n",
    "# Plot the histogram, the convolved signal, and optionally the Breit-Wigner\n",
    "# plt.figure(figsize=(10, 6))\n",
    "# plt.step(bin_centers, hist_values, label=\"Histogram\", where='mid', color='blue')  # Plot histogram\n",
    "# plt.plot(bin_centers,signal_model_values, label=\"model Signal\", color='red')  # Convolved signal\n",
    "# # Optionally plot the raw signal model (Breit-Wigner)\n",
    "# # plt.plot(bin_centers, gaussian_kernel_values, label=\"Gaussian Kernel\", color='green', linestyle='--')\n",
    "# # plt.title(\"Convolution of Breit-Wigner and Gaussian with Histogram\")\n",
    "# plt.xlabel(\"x (bin centers)\")\n",
    "# plt.ylabel(\"PDF / Histogram\")\n",
    "# plt.legend()\n",
    "# plt.grid()\n",
    "# plt.show()\n",
    "\n",
    "# Plot the result\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.plot(bin_centers, convolved_signal, label=\"Manual Convolution\", color='red')\n",
    "plt.legend()\n",
    "plt.show()\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "b19654c7",
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Evaluating PDFs...\n",
      "Breit-Wigner Values: [[0.03333333 0.03319965 0.03306625 ... 0.03306625 0.03319965 0.03333333]\n",
      " [0.03346661 0.03333239 0.03319845 ... 0.03319845 0.03333239 0.03346661]\n",
      " [0.03360068 0.03346593 0.03333145 ... 0.03333145 0.03346593 0.03360068]\n",
      " ...\n",
      " [0.03360068 0.03346593 0.03333145 ... 0.03333145 0.03346593 0.03360068]\n",
      " [0.03346661 0.03333239 0.03319845 ... 0.03319845 0.03333239 0.03346661]\n",
      " [0.03333333 0.03319965 0.03306625 ... 0.03306625 0.03319965 0.03333333]]\n",
      "Gaussian Kernel Values: [0.00088877 0.00090491 0.00092131 0.00093798 0.00095491 0.00097212\n",
      " 0.0009896  0.00100735 0.00102539 0.00104371 0.00106232 0.00108123\n",
      " 0.00110043 0.00111993 0.00113974 0.00115985 0.00118028 0.00120103\n",
      " 0.00122209 0.00124348 0.0012652  0.00128725 0.00130964 0.00133237\n",
      " 0.00135544 0.00137886 0.00140264 0.00142678 0.00145128 0.00147615\n",
      " 0.00150139 0.001527   0.001553   0.00157939 0.00160616 0.00163333\n",
      " 0.00166089 0.00168887 0.00171725 0.00174604 0.00177526 0.00180489\n",
      " 0.00183496 0.00186546 0.0018964  0.00192778 0.00195961 0.0019919\n",
      " 0.00202464 0.00205785 0.00209152 0.00212568 0.00216031 0.00219542\n",
      " 0.00223103 0.00226713 0.00230373 0.00234084 0.00237846 0.0024166\n",
      " 0.00245526 0.00249445 0.00253418 0.00257444 0.00261525 0.00265661\n",
      " 0.00269853 0.00274101 0.00278406 0.00282768 0.00287188 0.00291667\n",
      " 0.00296205 0.00300802 0.0030546  0.00310179 0.0031496  0.00319803\n",
      " 0.00324708 0.00329677 0.0033471  0.00339807 0.00344969 0.00350198\n",
      " 0.00355492 0.00360854 0.00366283 0.00371781 0.00377348 0.00382984\n",
      " 0.0038869  0.00394467 0.00400315 0.00406236 0.00412229 0.00418296\n",
      " 0.00424436 0.00430651 0.00436942 0.00443308 0.00449751 0.00456271\n",
      " 0.00462869 0.00469545 0.004763   0.00483135 0.00490051 0.00497048\n",
      " 0.00504126 0.00511286 0.0051853  0.00525857 0.00533269 0.00540766\n",
      " 0.00548348 0.00556016 0.00563772 0.00571615 0.00579546 0.00587566\n",
      " 0.00595675 0.00603875 0.00612165 0.00620547 0.00629021 0.00637587\n",
      " 0.00646247 0.00655001 0.0066385  0.00672794 0.00681834 0.0069097\n",
      " 0.00700203 0.00709534 0.00718964 0.00728493 0.00738121 0.0074785\n",
      " 0.00757679 0.0076761  0.00777644 0.00787779 0.00798019 0.00808362\n",
      " 0.00818809 0.00829362 0.00840021 0.00850785 0.00861657 0.00872636\n",
      " 0.00883723 0.00894919 0.00906224 0.00917638 0.00929163 0.00940799\n",
      " 0.00952545 0.00964404 0.00976376 0.0098846  0.01000657 0.01012969\n",
      " 0.01025395 0.01037936 0.01050593 0.01063365 0.01076254 0.0108926\n",
      " 0.01102383 0.01115625 0.01128984 0.01142462 0.0115606  0.01169777\n",
      " 0.01183614 0.01197572 0.01211651 0.0122585  0.01240172 0.01254616\n",
      " 0.01269182 0.0128387  0.01298682 0.01313618 0.01328677 0.01343861\n",
      " 0.01359169 0.01374601 0.01390159 0.01405842 0.01421651 0.01437586\n",
      " 0.01453647 0.01469834 0.01486148 0.01502589 0.01519157 0.01535852\n",
      " 0.01552675 0.01569625 0.01586704 0.0160391  0.01621244 0.01638706\n",
      " 0.01656297 0.01674016 0.01691864 0.0170984  0.01727945 0.01746179\n",
      " 0.01764542 0.01783033 0.01801653 0.01820402 0.01839279 0.01858286\n",
      " 0.01877421 0.01896684 0.01916077 0.01935597 0.01955246 0.01975023\n",
      " 0.01994929 0.02014962 0.02035123 0.02055411 0.02075827 0.0209637\n",
      " 0.0211704  0.02137837 0.0215876  0.02179809 0.02200985 0.02222285\n",
      " 0.02243711 0.02265262 0.02286937 0.02308736 0.02330659 0.02352706\n",
      " 0.02374875 0.02397167 0.0241958  0.02442115 0.02464771 0.02487548\n",
      " 0.02510444 0.0253346  0.02556595 0.02579847 0.02603218 0.02626705\n",
      " 0.02650309 0.02674028 0.02697862 0.02721811 0.02745873 0.02770048\n",
      " 0.02794334 0.02818732 0.02843241 0.02867859 0.02892586 0.02917421\n",
      " 0.02942363 0.02967412 0.02992565 0.03017823 0.03043184 0.03068648\n",
      " 0.03094213 0.03119879 0.03145644 0.03171508 0.03197468 0.03223525\n",
      " 0.03249677 0.03275923 0.03302262 0.03328693 0.03355214 0.03381825\n",
      " 0.03408523 0.03435309 0.0346218  0.03489135 0.03516173 0.03543293\n",
      " 0.03570494 0.03597773 0.0362513  0.03652564 0.03680072 0.03707654\n",
      " 0.03735307 0.03763032 0.03790825 0.03818685 0.03846612 0.03874603\n",
      " 0.03902657 0.03930773 0.03958948 0.03987181 0.04015471 0.04043816\n",
      " 0.04072214 0.04100663 0.04129162 0.04157709 0.04186303 0.04214941\n",
      " 0.04243622 0.04272344 0.04301105 0.04329904 0.04358738 0.04387606\n",
      " 0.04416506 0.04445436 0.04474394 0.04503379 0.04532387 0.04561418\n",
      " 0.04590469 0.04619539 0.04648625 0.04677725 0.04706838 0.04735961\n",
      " 0.04765092 0.0479423  0.04823371 0.04852515 0.04881659 0.04910801\n",
      " 0.04939938 0.0496907  0.04998192 0.05027304 0.05056404 0.05085488\n",
      " 0.05114555 0.05143602 0.05172628 0.0520163  0.05230606 0.05259554\n",
      " 0.05288471 0.05317355 0.05346205 0.05375016 0.05403789 0.05432519\n",
      " 0.05461205 0.05489844 0.05518435 0.05546974 0.0557546  0.0560389\n",
      " 0.05632262 0.05660573 0.05688821 0.05717004 0.0574512  0.05773165\n",
      " 0.05801138 0.05829036 0.05856858 0.05884599 0.05912259 0.05939835\n",
      " 0.05967324 0.05994724 0.06022032 0.06049247 0.06076366 0.06103386\n",
      " 0.06130305 0.0615712  0.0618383  0.06210432 0.06236923 0.06263301\n",
      " 0.06289564 0.06315709 0.06341734 0.06367637 0.06393414 0.06419065\n",
      " 0.06444586 0.06469975 0.0649523  0.06520348 0.06545327 0.06570165\n",
      " 0.06594859 0.06619408 0.06643808 0.06668057 0.06692154 0.06716095\n",
      " 0.06739879 0.06763503 0.06786965 0.06810263 0.06833394 0.06856357\n",
      " 0.06879148 0.06901767 0.06924209 0.06946475 0.0696856  0.06990464\n",
      " 0.07012183 0.07033717 0.07055062 0.07076216 0.07097178 0.07117945\n",
      " 0.07138515 0.07158887 0.07179058 0.07199026 0.07218789 0.07238345\n",
      " 0.07257692 0.07276829 0.07295753 0.07314462 0.07332955 0.07351229\n",
      " 0.07369283 0.07387115 0.07404723 0.07422105 0.07439259 0.07456185\n",
      " 0.07472879 0.0748934  0.07505567 0.07521558 0.07537311 0.07552824\n",
      " 0.07568097 0.07583127 0.07597912 0.07612452 0.07626744 0.07640788\n",
      " 0.07654581 0.07668123 0.07681412 0.07694446 0.07707224 0.07719745\n",
      " 0.07732007 0.07744009 0.07755751 0.0776723  0.07778445 0.07789395\n",
      " 0.0780008  0.07810497 0.07820647 0.07830527 0.07840136 0.07849475\n",
      " 0.07858541 0.07867333 0.07875852 0.07884095 0.07892062 0.07899752\n",
      " 0.07907164 0.07914298 0.07921153 0.07927728 0.07934021 0.07940034\n",
      " 0.07945764 0.07951212 0.07956376 0.07961257 0.07965853 0.07970164\n",
      " 0.0797419  0.07977931 0.07981385 0.07984552 0.07987433 0.07990027\n",
      " 0.07992333 0.07994351 0.07996081 0.07997524 0.07998678 0.07999543\n",
      " 0.08000121 0.08000409 0.08000409 0.08000121 0.07999543 0.07998678\n",
      " 0.07997524 0.07996081 0.07994351 0.07992333 0.07990027 0.07987433\n",
      " 0.07984552 0.07981385 0.07977931 0.0797419  0.07970164 0.07965853\n",
      " 0.07961257 0.07956376 0.07951212 0.07945764 0.07940034 0.07934021\n",
      " 0.07927728 0.07921153 0.07914298 0.07907164 0.07899752 0.07892062\n",
      " 0.07884095 0.07875852 0.07867333 0.07858541 0.07849475 0.07840136\n",
      " 0.07830527 0.07820647 0.07810497 0.0780008  0.07789395 0.07778445\n",
      " 0.0776723  0.07755751 0.07744009 0.07732007 0.07719745 0.07707224\n",
      " 0.07694446 0.07681412 0.07668123 0.07654581 0.07640788 0.07626744\n",
      " 0.07612452 0.07597912 0.07583127 0.07568097 0.07552824 0.07537311\n",
      " 0.07521558 0.07505567 0.0748934  0.07472879 0.07456185 0.07439259\n",
      " 0.07422105 0.07404723 0.07387115 0.07369283 0.07351229 0.07332955\n",
      " 0.07314462 0.07295753 0.07276829 0.07257692 0.07238345 0.07218789\n",
      " 0.07199026 0.07179058 0.07158887 0.07138515 0.07117945 0.07097178\n",
      " 0.07076216 0.07055062 0.07033717 0.07012183 0.06990464 0.0696856\n",
      " 0.06946475 0.06924209 0.06901767 0.06879148 0.06856357 0.06833394\n",
      " 0.06810263 0.06786965 0.06763503 0.06739879 0.06716095 0.06692154\n",
      " 0.06668057 0.06643808 0.06619408 0.06594859 0.06570165 0.06545327\n",
      " 0.06520348 0.0649523  0.06469975 0.06444586 0.06419065 0.06393414\n",
      " 0.06367637 0.06341734 0.06315709 0.06289564 0.06263301 0.06236923\n",
      " 0.06210432 0.0618383  0.0615712  0.06130305 0.06103386 0.06076366\n",
      " 0.06049247 0.06022032 0.05994724 0.05967324 0.05939835 0.05912259\n",
      " 0.05884599 0.05856858 0.05829036 0.05801138 0.05773165 0.0574512\n",
      " 0.05717004 0.05688821 0.05660573 0.05632262 0.0560389  0.0557546\n",
      " 0.05546974 0.05518435 0.05489844 0.05461205 0.05432519 0.05403789\n",
      " 0.05375016 0.05346205 0.05317355 0.05288471 0.05259554 0.05230606\n",
      " 0.0520163  0.05172628 0.05143602 0.05114555 0.05085488 0.05056404\n",
      " 0.05027304 0.04998192 0.0496907  0.04939938 0.04910801 0.04881659\n",
      " 0.04852515 0.04823371 0.0479423  0.04765092 0.04735961 0.04706838\n",
      " 0.04677725 0.04648625 0.04619539 0.04590469 0.04561418 0.04532387\n",
      " 0.04503379 0.04474394 0.04445436 0.04416506 0.04387606 0.04358738\n",
      " 0.04329904 0.04301105 0.04272344 0.04243622 0.04214941 0.04186303\n",
      " 0.04157709 0.04129162 0.04100663 0.04072214 0.04043816 0.04015471\n",
      " 0.03987181 0.03958948 0.03930773 0.03902657 0.03874603 0.03846612\n",
      " 0.03818685 0.03790825 0.03763032 0.03735307 0.03707654 0.03680072\n",
      " 0.03652564 0.0362513  0.03597773 0.03570494 0.03543293 0.03516173\n",
      " 0.03489135 0.0346218  0.03435309 0.03408523 0.03381825 0.03355214\n",
      " 0.03328693 0.03302262 0.03275923 0.03249677 0.03223525 0.03197468\n",
      " 0.03171508 0.03145644 0.03119879 0.03094213 0.03068648 0.03043184\n",
      " 0.03017823 0.02992565 0.02967412 0.02942363 0.02917421 0.02892586\n",
      " 0.02867859 0.02843241 0.02818732 0.02794334 0.02770048 0.02745873\n",
      " 0.02721811 0.02697862 0.02674028 0.02650309 0.02626705 0.02603218\n",
      " 0.02579847 0.02556595 0.0253346  0.02510444 0.02487548 0.02464771\n",
      " 0.02442115 0.0241958  0.02397167 0.02374875 0.02352706 0.02330659\n",
      " 0.02308736 0.02286937 0.02265262 0.02243711 0.02222285 0.02200985\n",
      " 0.02179809 0.0215876  0.02137837 0.0211704  0.0209637  0.02075827\n",
      " 0.02055411 0.02035123 0.02014962 0.01994929 0.01975023 0.01955246\n",
      " 0.01935597 0.01916077 0.01896684 0.01877421 0.01858286 0.01839279\n",
      " 0.01820402 0.01801653 0.01783033 0.01764542 0.01746179 0.01727945\n",
      " 0.0170984  0.01691864 0.01674016 0.01656297 0.01638706 0.01621244\n",
      " 0.0160391  0.01586704 0.01569625 0.01552675 0.01535852 0.01519157\n",
      " 0.01502589 0.01486148 0.01469834 0.01453647 0.01437586 0.01421651\n",
      " 0.01405842 0.01390159 0.01374601 0.01359169 0.01343861 0.01328677\n",
      " 0.01313618 0.01298682 0.0128387  0.01269182 0.01254616 0.01240172\n",
      " 0.0122585  0.01211651 0.01197572 0.01183614 0.01169777 0.0115606\n",
      " 0.01142462 0.01128984 0.01115625 0.01102383 0.0108926  0.01076254\n",
      " 0.01063365 0.01050593 0.01037936 0.01025395 0.01012969 0.01000657\n",
      " 0.0098846  0.00976376 0.00964404 0.00952545 0.00940799 0.00929163\n",
      " 0.00917638 0.00906224 0.00894919 0.00883723 0.00872636 0.00861657\n",
      " 0.00850785 0.00840021 0.00829362 0.00818809 0.00808362 0.00798019\n",
      " 0.00787779 0.00777644 0.0076761  0.00757679 0.0074785  0.00738121\n",
      " 0.00728493 0.00718964 0.00709534 0.00700203 0.0069097  0.00681834\n",
      " 0.00672794 0.0066385  0.00655001 0.00646247 0.00637587 0.00629021\n",
      " 0.00620547 0.00612165 0.00603875 0.00595675 0.00587566 0.00579546\n",
      " 0.00571615 0.00563772 0.00556016 0.00548348 0.00540766 0.00533269\n",
      " 0.00525857 0.0051853  0.00511286 0.00504126 0.00497048 0.00490051\n",
      " 0.00483135 0.004763   0.00469545 0.00462869 0.00456271 0.00449751\n",
      " 0.00443308 0.00436942 0.00430651 0.00424436 0.00418296 0.00412229\n",
      " 0.00406236 0.00400315 0.00394467 0.0038869  0.00382984 0.00377348\n",
      " 0.00371781 0.00366283 0.00360854 0.00355492 0.00350198 0.00344969\n",
      " 0.00339807 0.0033471  0.00329677 0.00324708 0.00319803 0.0031496\n",
      " 0.00310179 0.0030546  0.00300802 0.00296205 0.00291667 0.00287188\n",
      " 0.00282768 0.00278406 0.00274101 0.00269853 0.00265661 0.00261525\n",
      " 0.00257444 0.00253418 0.00249445 0.00245526 0.0024166  0.00237846\n",
      " 0.00234084 0.00230373 0.00226713 0.00223103 0.00219542 0.00216031\n",
      " 0.00212568 0.00209152 0.00205785 0.00202464 0.0019919  0.00195961\n",
      " 0.00192778 0.0018964  0.00186546 0.00183496 0.00180489 0.00177526\n",
      " 0.00174604 0.00171725 0.00168887 0.00166089 0.00163333 0.00160616\n",
      " 0.00157939 0.001553   0.001527   0.00150139 0.00147615 0.00145128\n",
      " 0.00142678 0.00140264 0.00137886 0.00135544 0.00133237 0.00130964\n",
      " 0.00128725 0.0012652  0.00124348 0.00122209 0.00120103 0.00118028\n",
      " 0.00115985 0.00113974 0.00111993 0.00110043 0.00108123 0.00106232\n",
      " 0.00104371 0.00102539 0.00100735 0.0009896  0.00097212 0.00095491\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      " 0.00093798 0.00092131 0.00090491 0.00088877]\n"
     ]
    },
    {
     "ename": "ValueError",
     "evalue": "object too deep for desired array",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m/tmp/ipykernel_439/1124369556.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     76\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     77\u001b[0m     \u001b[0;31m# Manual convolution\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 78\u001b[0;31m     \u001b[0mmanual_convolution_fine\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconvolve\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msignal_model_values_fine_1d\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mgaussian_kernel_values_fine_1d\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmode\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m'same'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     79\u001b[0m     \u001b[0mmanual_convolution_fine\u001b[0m \u001b[0;34m/=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmax\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmanual_convolution_fine\u001b[0m\u001b[0;34m)\u001b[0m  \u001b[0;31m# Normalize\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     80\u001b[0m     \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Manual Convolution (Normalized):\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmanual_convolution_fine\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/numpy/core/overrides.py\u001b[0m in \u001b[0;36mconvolve\u001b[0;34m(*args, **kwargs)\u001b[0m\n",
      "\u001b[0;32m/cvmfs/sft.cern.ch/lcg/views/LCG_105a_swan/x86_64-el9-gcc13-opt/lib/python3.9/site-packages/numpy/core/numeric.py\u001b[0m in \u001b[0;36mconvolve\u001b[0;34m(a, v, mode)\u001b[0m\n\u001b[1;32m    848\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mv\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    849\u001b[0m         \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'v cannot be empty'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 850\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0mmultiarray\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcorrelate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0ma\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mv\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m-\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmode\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    851\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    852\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mValueError\u001b[0m: object too deep for desired array"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import tensorflow as tf\n",
    "import zfit\n",
    "import uuid  # To generate unique parameter names\n",
    "# Enable eager execution for TensorFlow\n",
    "tf.config.experimental_run_functions_eagerly(True)\n",
    "\n",
    "# Define the observable (adjust the limits as necessary for your use case)\n",
    "obs = zfit.Space(\"x\", limits=(75, 105))\n",
    "\n",
    "# Generate unique names for parameters to avoid conflicts\n",
    "unique_id = uuid.uuid4().hex[:8]  # Generate a short unique identifier\n",
    "\n",
    "# Parameters for the Gaussian kernel\n",
    "mu_gaussian = zfit.Parameter(f\"mu_gaussian_{unique_id}\", 90.0, lower=75.0, upper=105.0)\n",
    "sigma_gaussian = zfit.Parameter(f\"sigma_gaussian_{unique_id}\", 5.0, lower=0.1, upper=20.0)\n",
    "\n",
    "# Parameters for the Breit-Wigner\n",
    "M_bw = zfit.Parameter(f\"M_bw_{unique_id}\", 90.0, lower=75.0, upper=105.0)\n",
    "Gamma_bw = zfit.Parameter(f\"Gamma_bw_{unique_id}\", 2.0, lower=0.1, upper=10.0)\n",
    "\n",
    "# Custom Breit-Wigner PDF\n",
    "class BreitWignerPDF(zfit.pdf.BasePDF):\n",
    "    def _unnormalized_pdf(self, x):\n",
    "        x_tensor = x.value()  # Get tensor values\n",
    "        M_val = tf.convert_to_tensor(zfit.run(M_bw), dtype=tf.float64)\n",
    "        Gamma_val = tf.convert_to_tensor(zfit.run(Gamma_bw), dtype=tf.float64)\n",
    "        return 1 / ((x_tensor - M_val) ** 2 + (Gamma_val / 2) ** 2)\n",
    "\n",
    "# Instantiate the Breit-Wigner PDF\n",
    "signal_model = BreitWignerPDF(obs=obs)\n",
    "\n",
    "# Create the Gaussian kernel and the convolved signal\n",
    "gaussian_kernel = zfit.pdf.Gauss(mu=mu_gaussian, sigma=sigma_gaussian, obs=obs)\n",
    "\n",
    "# Convolve the Breit-Wigner with the Gaussian kernel\n",
    "signal_convolved = zfit.pdf.FFTConvPDFV1(func=signal_model, kernel=gaussian_kernel)\n",
    "\n",
    "# Histogram values and edges (provided data)\n",
    "hist_values = np.array([\n",
    "    9, 7, 11, 2, 9, 10, 10, 8, 6, 11, 8, 12, 11, 11, 18, 14, 8, 17, 10, 13,\n",
    "    14, 24, 23, 19, 19, 34, 28, 24, 27, 29, 27, 42, 29, 41, 43, 45, 40, 56,\n",
    "    66, 53, 78, 84, 80, 115, 129, 123, 142, 156, 185, 189, 225, 241, 252, 281,\n",
    "    297, 319, 334, 363, 405, 412, 396, 351, 340, 370, 320, 258, 269, 238, 188,\n",
    "    174, 147, 116, 107, 93, 87, 87, 59, 59, 57, 50, 41, 35, 38, 41, 24, 29,\n",
    "    26, 27, 21, 16, 17, 14, 12, 15, 13, 13, 12, 14, 14, 11, 7, 11, 9, 22, 16,\n",
    "    11, 6, 6, 13, 2, 5, 6, 6, 6, 6, 4, 6, 3, 6, 5\n",
    "])\n",
    "hist_edges = np.linspace(76, 106, len(hist_values) + 1)\n",
    "\n",
    "# Calculate the bin centers (mid-points of each bin)\n",
    "bin_centers = (hist_edges[:-1] + hist_edges[1:]) / 2\n",
    "\n",
    "# Convert bin centers to TensorFlow tensor\n",
    "x_tensor = tf.convert_to_tensor(bin_centers, dtype=tf.float64)\n",
    "\n",
    "# Finer binning for manual convolution\n",
    "x_fine = np.linspace(75, 105, 1000)\n",
    "x_tensor_fine = tf.convert_to_tensor(x_fine, dtype=tf.float64)\n",
    "\n",
    "# Check for NaN or Inf issues during evaluation\n",
    "try:\n",
    "    print(\"Evaluating PDFs...\")\n",
    "    # Evaluate the pure signal model (Breit-Wigner) at the bin centers\n",
    "    signal_model_values_fine = signal_model.pdf(x_tensor_fine).numpy()  # Convert to numpy for plotting\n",
    "    print(\"Breit-Wigner Values:\", signal_model_values_fine)\n",
    "\n",
    "    # Evaluate the Gaussian kernel at the bin centers\n",
    "    gaussian_kernel_values_fine = gaussian_kernel.pdf(x_tensor_fine).numpy()  # Convert to numpy for plotting\n",
    "    print(\"Gaussian Kernel Values:\", gaussian_kernel_values_fine)\n",
    "\n",
    "    # Fix: Ensure arrays are 1D for manual convolution\n",
    "    signal_model_values_fine_1d = np.squeeze(signal_model_values_fine)  # Convert to 1D if needed\n",
    "    gaussian_kernel_values_fine_1d = np.squeeze(gaussian_kernel_values_fine)  # Convert to 1D if needed\n",
    "\n",
    "    # Manual convolution\n",
    "    manual_convolution_fine = np.convolve(signal_model_values_fine_1d, gaussian_kernel_values_fine_1d, mode='same')\n",
    "    manual_convolution_fine /= np.max(manual_convolution_fine)  # Normalize\n",
    "    print(\"Manual Convolution (Normalized):\", manual_convolution_fine)\n",
    "\n",
    "    # Evaluate the convolved signal at the bin centers\n",
    "    signal_convolved_values = signal_convolved.pdf(x_tensor).numpy()  # Convert to numpy for plotting\n",
    "    print(\"Convolved Signal Values:\", signal_convolved_values)\n",
    "except tf.errors.InvalidArgumentError as e:\n",
    "    print(\"Invalid Argument Error: Check if input data leads to NaNs or Infs. Error:\", e)\n",
    "    raise\n",
    "\n",
    "# Plot the results\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.plot(x_fine, manual_convolution_fine, label=\"Manual Convolution\", color=\"red\", linewidth=1.5)\n",
    "plt.plot(bin_centers, signal_convolved_values, label=\"Convolved Signal (FFT)\", color=\"blue\", linestyle=\"--\")\n",
    "plt.title(\"Comparison of Manual Convolution and FFT-Based Convolution\")\n",
    "plt.xlabel(\"x\")\n",
    "plt.ylabel(\"PDF\")\n",
    "plt.legend()\n",
    "plt.grid()\n",
    "plt.show()\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fdaaca81",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
