{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "70aacf02",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import uproot\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) *(2 * N2_prime + N1_prime)) / (4*N2 * N2_prime)\n",
    "    term3 = ((2 * N2 + N1) **2) / (4*N2)\n",
    "    return term1 * term2 * term3\n",
    "\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = (4 * (delta_N2) ** 2 + (delta_N1) ** 2) / ((2 * N2 + N1) ** 2)\n",
    "    term4 = (4 * (delta_N2_prime) ** 2 + (delta_N1_prime) ** 2) / ((2 * N2_prime + N1_prime) ** 2)\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "# Load data from text files\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\"]\n",
    "N2_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\"]\n",
    "N1_prime_files = [\"N_1Iee1.txt\", \"N_1Iee2.txt\", \"N_1Iee3.txt\"]\n",
    "N2_prime_files = [\"N_2Iee1.txt\", \"N_2Iee2.txt\", \"N_2Iee3.txt\"]\n",
    "delta_N1_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\"]\n",
    "delta_N2_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Iee1.txt\", \"eN_1Iee2.txt\", \"eN_1Iee3.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Iee1.txt\", \"eN_2Iee2.txt\", \"eN_2Iee3.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.018*0.106)\n",
    "constant_value_2 =  0.00000369\n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 42, 83\n",
    "x_bin_start3, x_bin_end3 = 83, 120\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_EE\",L_values1)\n",
    "print(\"errorlumi_EE\",delta_L_over_L_squared_values1)\n",
    "\n",
    "rat = [lbril_values[0]/L_values1[0], lbril_values[1]/L_values1[1] , lbril_values[2]/L_values1[2]]\n",
    "lbril_values = [116086.333 , 100081.51 , 93398.989]\n",
    "\n",
    "print(\"bril\",lbril_values)\n",
    "\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.errorbar(lumisec_midpoints, rat , fmt='o', color='red',  capsize=5,label=\"lumi_bril/lumi_EE\")\n",
    "\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"lumi_bril/lumi_EE\")\n",
    "plt.legend()\n",
    "plt.grid()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "d0bf691c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lumi_EE [111136.43349056435, 95611.12468628376, 79060.80995194193]\n",
      "bril [114618.486, 97972.294, 81904.476]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x720 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import uproot\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) **2 )*((2 * N2_prime + N1_prime)**2) / (16*N2 * (N2_prime)**2)\n",
    "    term3 = ((2 * N2 + N1)*(2 * N2_prime + N1_prime)) / (4*N2* N2_prime)\n",
    "    return term1 * term2 * term3\n",
    "\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = ((4 * delta_N2 ** 2 + delta_N1 ** 2) / (2 * N2 + N1)) ** 2\n",
    "    term4 = ((4 * delta_N2_prime ** 2 + delta_N1_prime ** 2) / (2 * N2_prime + N1_prime)) ** 2\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "# Load data from text files\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\"]\n",
    "N2_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\"]\n",
    "N1_prime_files = [\"N_1Iee1.txt\", \"N_1Iee2.txt\", \"N_1Iee3.txt\"]\n",
    "N2_prime_files = [\"N_2Iee1.txt\", \"N_2Iee2.txt\", \"N_2Iee3.txt\"]\n",
    "delta_N1_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\"]\n",
    "delta_N2_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Iee1.txt\", \"eN_1Iee2.txt\", \"eN_1Iee3.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Iee1.txt\", \"eN_2Iee2.txt\", \"eN_2Iee3.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.073*0.106)\n",
    "constant_value_2 =  0.000001582 \n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 41, 81\n",
    "x_bin_start3, x_bin_end3 = 81, 119\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_EE\",L_values1)\n",
    "\n",
    "lbril_values = [114618.486  , 97972.294 , 81904.476]\n",
    "rat = [lbril_values[0]/L_values1[0], lbril_values[1]/L_values1[1] , lbril_values[2]/L_values1[2]]\n",
    "print(\"bril\",lbril_values)\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.errorbar(lumisec_midpoints,L_values1 ,fmt='o', color='red',  capsize=5)\n",
    "plt.errorbar(lumisec_midpoints, lbril_values , fmt='o', color='black',  capsize=5)\n",
    "# plt.errorbar(lumisec_midpoints, rat , fmt='o', color='red', capsize=5,label=\"lumi_bril/lumi_EE\")\n",
    "\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"L\")\n",
    "plt.title(\"L vs Lumisec\")\n",
    "plt.grid()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "423868c5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lumi_BE [104538.17036397796, 89200.83999217776, 73517.43533196853]\n",
      "bril [114618.486, 97972.294, 81904.476]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x720 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import uproot\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) **2 )*((2 * N2_prime + N1_prime)**2) / (16*N2 * (N2_prime)**2)\n",
    "    term3 = ((2 * N2 + N1)*(2 * N2_prime + N1_prime)) / (4*N2* N2_prime)\n",
    "    return term1 * term2 * term3\n",
    "\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = ((4 * delta_N2 ** 2 + delta_N1 ** 2) / (2 * N2 + N1)) ** 2\n",
    "    term4 = ((4 * delta_N2_prime ** 2 + delta_N1_prime ** 2) / (2 * N2_prime + N1_prime)) ** 2\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "# Load data from text files\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hbe4.txt\", \"N_1hbe5.txt\", \"N_1hbe6.txt\"]\n",
    "N2_files = [\"N_2hbe4.txt\", \"N_2hbe5.txt\", \"N_2hbe6.txt\"]\n",
    "N1_prime_files = [\"N_1Ibe4.txt\", \"N_1Ibe5.txt\", \"N_1Ibe6.txt\"]\n",
    "N2_prime_files = [\"N_2Ibe4.txt\", \"N_2Ibe5.txt\", \"N_2Ibe6.txt\"]\n",
    "delta_N1_files = [\"eN_1hbe4.txt\", \"eN_1hbe5.txt\", \"eN_1hbe6.txt\"]\n",
    "delta_N2_files = [\"eN_2hbe4.txt\", \"eN_2hbe5.txt\", \"eN_2hbe6.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Ibe4.txt\", \"eN_1Ibe5.txt\", \"eN_1Ibe6.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Ibe4.txt\", \"eN_2Ibe5.txt\", \"eN_2Ibe6.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.073*0.112)\n",
    "constant_value_2 =  0.000001582 \n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 41, 81\n",
    "x_bin_start3, x_bin_end3 = 81, 119\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_BE\",L_values1)\n",
    "\n",
    "lbril_values = [114618.486  , 97972.294 , 81904.476]\n",
    "rat = [lbril_values[0]/L_values1[0], lbril_values[1]/L_values1[1] , lbril_values[2]/L_values1[2]]\n",
    "print(\"bril\",lbril_values)\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.errorbar(lumisec_midpoints,L_values1  , fmt='o', color='red',  capsize=5)\n",
    "plt.errorbar(lumisec_midpoints, lbril_values , fmt='o', color='black',  capsize=5)\n",
    "# plt.errorbar(lumisec_midpoints, rat ,fmt='o', color='red', capsize=5,label=\"lumi_bril/lumi_EE\")\n",
    "\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"L\")\n",
    "plt.title(\"L vs Lumisec\")\n",
    "plt.grid()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "4eee652a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lumi_BB [125129.85682814714, 105982.53742888258, 88180.27290587434]\n",
      "bril [114618.486, 97972.294, 81904.476]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x720 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import uproot\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) **2 )*((2 * N2_prime + N1_prime)**2) / (16*N2 * (N2_prime)**2)\n",
    "    term3 = ((2 * N2 + N1)*(2 * N2_prime + N1_prime)) / (4*N2* N2_prime)\n",
    "    return term1 * term2 * term3\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = ((4 * delta_N2 ** 2 + delta_N1 ** 2) / (2 * N2 + N1)) ** 2\n",
    "    term4 = ((4 * delta_N2_prime ** 2 + delta_N1_prime ** 2) / (2 * N2_prime + N1_prime)) ** 2\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "# Load data from text files\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hbb7.txt\", \"N_1hbb8.txt\", \"N_1hbb9.txt\"] \n",
    "N2_files = [\"N_2hbb7.txt\", \"N_2hbb8.txt\", \"N_2hbb9.txt\"]\n",
    "N1_prime_files = [\"N_1Ibb9.txt\", \"N_1Ibb10.txt\", \"N_1Ibb11.txt\"]\n",
    "N2_prime_files = [\"N_2Ibb9.txt\", \"N_2Ibb10.txt\", \"N_2Ibb11.txt\"]\n",
    "delta_N1_files = [\"eN_1hbb7.txt\", \"eN_1hbb8.txt\", \"eN_1hbb9.txt\"]\n",
    "delta_N2_files = [\"eN_2hbb7.txt\", \"eN_2hbb8.txt\", \"eN_2hbb9.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Ibb9.txt\", \"eN_1Ibb10.txt\", \"eN_1Ibb11.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Ibb9.txt\", \"eN_2Ibb10.txt\", \"eN_2Ibb11.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.073*0.073)\n",
    "constant_value_2 =  0.000001582 \n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 41, 81\n",
    "x_bin_start3, x_bin_end3 = 81, 119\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_BB\",L_values1)\n",
    "\n",
    "lbril_values = [114618.486  , 97972.294 , 81904.476]\n",
    "rat = [lbril_values[0]/L_values1[0], lbril_values[1]/L_values1[1] , lbril_values[2]/L_values1[2]]\n",
    "print(\"bril\",lbril_values)\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.errorbar(lumisec_midpoints,L_values1  , fmt='o', color='red',  capsize=5)\n",
    "plt.errorbar(lumisec_midpoints, lbril_values , fmt='o', color='black',  capsize=5)\n",
    "# plt.errorbar(lumisec_midpoints, rat ,fmt='o', color='red', capsize=5,label=\"lumi_bril/lumi_EE\")\n",
    "\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"L\")\n",
    "plt.title(\"L vs Lumisec\")\n",
    "plt.grid()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "db040765",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lumi_EE [99663.03191473045, 85530.01752005453, 70978.6528632015]\n",
      "errorlumi_EE [26.463186089330147, 19.66965497555974, 18.277960785446947]\n",
      "bril [114618.486, 97972.294, 81904.476]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x720 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) ** 2) / (4 * N2) \n",
    "    term3 = ((2 * N2 + N1) * (2 * N2_prime + N1_prime)) / (4 * N2 * N2_prime)\n",
    "    return term1 * term2 * term3\n",
    "\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = ((4 * delta_N2 ** 2 + delta_N1 ** 2) / (2 * N2 + N1)) ** 2\n",
    "    term4 = ((4 * delta_N2_prime ** 2 + delta_N1_prime ** 2) / (2 * N2_prime + N1_prime)) ** 2\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hbb7.txt\", \"N_1hbb8.txt\", \"N_1hbb9.txt\"] \n",
    "N2_files = [\"N_2hbb7.txt\", \"N_2hbb8.txt\", \"N_2hbb9.txt\"]\n",
    "N1_prime_files = [\"N_1Ibb9.txt\", \"N_1Ibb10.txt\", \"N_1Ibb11.txt\"]\n",
    "N2_prime_files = [\"N_2Ibb9.txt\", \"N_2Ibb10.txt\", \"N_2Ibb11.txt\"]\n",
    "delta_N1_files = [\"eN_1hbb7.txt\", \"eN_1hbb8.txt\", \"eN_1hbb9.txt\"]\n",
    "delta_N2_files = [\"eN_2hbb7.txt\", \"eN_2hbb8.txt\", \"eN_2hbb9.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Ibb9.txt\", \"eN_1Ibb10.txt\", \"eN_1Ibb11.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Ibb9.txt\", \"eN_2Ibb10.txt\", \"eN_2Ibb11.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.073*0.073)\n",
    "constant_value_2 =  0.000001582 \n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 41, 81\n",
    "x_bin_start3, x_bin_end3 = 81, 119\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_EE\",L_values1)\n",
    "print(\"errorlumi_EE\",delta_L_over_L_squared_values1)\n",
    "\n",
    "lbril_values = [114618.486  , 97972.294 , 81904.476]\n",
    "rat = [lbril_values[0]/L_values1[0], lbril_values[1]/L_values1[1] , lbril_values[2]/L_values1[2]]\n",
    "print(\"bril\",lbril_values)\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.errorbar(lumisec_midpoints,L_values1  ,yerr= delta_L_over_L_squared_values1, fmt='o', color='red',  capsize=5)\n",
    "plt.errorbar(lumisec_midpoints, lbril_values , fmt='o', color='black',  capsize=5)\n",
    "# plt.errorbar(lumisec_midpoints, rat ,fmt='o', color='red', capsize=5,label=\"lumi_bril/lumi_EE\")\n",
    "\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"L\")\n",
    "plt.title(\"L vs Lumisec\")\n",
    "plt.grid()\n",
    "plt.show()\n",
    "# lumi_EE [99663.03191473045, 85530.01752005453, 70978.6528632015]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "893b8440",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f9d3a7bf",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
