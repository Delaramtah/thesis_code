{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "ada76428",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Final error squared for group 1hee1: 0.0009358969927549031\n",
      "Final error squared for group 1hee2: 0.0009602182987284052\n",
      "Final error squared for group 1hee3: 0.0010040051546537413\n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "\n",
    "# Function to read values and errors\n",
    "def read_values_and_errors(file1, file2):\n",
    "    \"\"\"\n",
    "    Reads a pair of values from two files and returns the values as floats.\n",
    "    \"\"\"\n",
    "    with open(file1, 'r') as f1, open(file2, 'r') as f2:\n",
    "        value1 = float(f1.read().strip())\n",
    "        value2 = float(f2.read().strip())\n",
    "    return value1, value2\n",
    "\n",
    "# Group files by their suffix (e.g., \"hee1\")\n",
    "def group_files_by_suffix(file_list_1, file_list_2):\n",
    "    \"\"\"\n",
    "    Groups files based on their shared suffix (e.g., \"hee1\").\n",
    "    Assumes filenames follow the format N_<group>.txt.\n",
    "    \"\"\"\n",
    "    groups = {}\n",
    "\n",
    "    for f1, f2 in zip(file_list_1, file_list_2):\n",
    "        # Extract the shared suffix (e.g., \"hee1\")\n",
    "        suffix = f1.split('_')[1].replace('.txt', '')  # Extract the part after '_'\n",
    "        groups[suffix] = {\"file1\": f1, \"file2\": f2}\n",
    "    \n",
    "    return groups\n",
    "\n",
    "# Function to calculate the final error\n",
    "def calculate_final_error(groups, error_files_1, error_files_2):\n",
    "    \"\"\"\n",
    "    Calculates the final error using the formula:\n",
    "    (\\delta_\\epsilon / \\epsilon)^2 = (\\delta_n / n)^2 + (\\delta_{2n + n'}) / (2n + n')^2\n",
    "    \"\"\"\n",
    "    final_errors = []\n",
    "\n",
    "    for suffix, files in groups.items():\n",
    "        # Get the filenames for n and n' files\n",
    "        n_file = files[\"file1\"]  # e.g., N_1hee1.txt\n",
    "        n_prime_file = files[\"file2\"]  # e.g., N_2hee1.txt\n",
    "\n",
    "        # Match error files based on file structure\n",
    "        error_file_1_matches = [ef for ef in error_files_1 if suffix in ef]\n",
    "        error_file_2_matches = [ef for ef in error_files_2 if suffix.replace(\"1h\", \"2h\") in ef]\n",
    "\n",
    "\n",
    "        # Ensure both error files exist\n",
    "        if not error_file_1_matches or not error_file_2_matches:\n",
    "            print(f\"Error: Missing error file for suffix {suffix}. Skipping...\")\n",
    "            continue  # Skip this group if any file is missing\n",
    "\n",
    "        error_file_1 = error_file_1_matches[0]\n",
    "        error_file_2 = error_file_2_matches[0]\n",
    "\n",
    "        # Read values and errors\n",
    "        n, n_prime = read_values_and_errors(n_file, n_prime_file)\n",
    "        dn, dn_prime = read_values_and_errors(error_file_1, error_file_2)\n",
    "\n",
    "        # Calculate the denominator (2n + n')\n",
    "        denominator = 2 * n + n_prime\n",
    "\n",
    "        # Calculate the individual terms in the formula\n",
    "        term1 = (dn / n) ** 2\n",
    "        term2 = (dn_prime / denominator) ** 2\n",
    "\n",
    "        # Calculate the final error squared\n",
    "        final_error_squared = term1 + term2\n",
    "\n",
    "        # Append the final error (squared)\n",
    "        final_errors.append((suffix, final_error_squared))\n",
    "    \n",
    "    return final_errors\n",
    "\n",
    "\n",
    "# Example Usage\n",
    "n_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\"]\n",
    "n_prime_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\"]\n",
    "\n",
    "n_error_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\"]\n",
    "n_prime_error_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\"]\n",
    "\n",
    "# Group files by their suffix\n",
    "groups = group_files_by_suffix(n_files, n_prime_files)\n",
    "\n",
    "# Calculate final errors\n",
    "final_errors = calculate_final_error(groups, n_error_files, n_prime_error_files)\n",
    "\n",
    "# Print the results\n",
    "for suffix, error in final_errors:\n",
    "    print(f\"Final error squared for group {suffix}: {error}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8fb579f1",
   "metadata": {},
   "outputs": [],
   "source": [
    "import math\n",
    "\n",
    "# Function to read values and errors\n",
    "def read_values_and_errors(file1, file2):\n",
    "    \"\"\"\n",
    "    Reads a pair of values from two files and returns the values as floats.\n",
    "    \"\"\"\n",
    "    with open(file1, 'r') as f1, open(file2, 'r') as f2:\n",
    "        value1 = float(f1.read().strip())\n",
    "        value2 = float(f2.read().strip())\n",
    "    return value1, value2\n",
    "\n",
    "# Group files by their suffix (e.g., \"hee1\")\n",
    "def group_files_by_suffix(file_list_1, file_list_2):\n",
    "    \"\"\"\n",
    "    Groups files based on their shared suffix (e.g., \"hee1\").\n",
    "    Assumes filenames follow the format N_<group>.txt.\n",
    "    \"\"\"\n",
    "    groups = {}\n",
    "\n",
    "    for f1, f2 in zip(file_list_1, file_list_2):\n",
    "        # Extract the shared suffix (e.g., \"hee1\")\n",
    "        suffix = f1.split('_')[1].replace('.txt', '')  # Extract the part after '_'\n",
    "        groups[suffix] = {\"file1\": f1, \"file2\": f2}\n",
    "    \n",
    "    return groups\n",
    "\n",
    "# Function to calculate the final error\n",
    "def calculate_final_error(groups, error_files_1, error_files_2):\n",
    "    \"\"\"\n",
    "    Calculates the final error using the formula:\n",
    "    (\\delta_\\epsilon / \\epsilon)^2 = (\\delta_n / n)^2 + (\\delta_{2n + n'}) / (2n + n')^2\n",
    "    \"\"\"\n",
    "    final_errors = []\n",
    "\n",
    "    for suffix, files in groups.items():\n",
    "        # Get the filenames for n and n' files\n",
    "        n_file = files[\"file1\"]  # e.g., N_1hee1.txt\n",
    "        n_prime_file = files[\"file2\"]  # e.g., N_2hee1.txt\n",
    "\n",
    "        # Match error files based on file structure\n",
    "        error_file_1_matches = [ef for ef in error_files_1 if suffix in ef]\n",
    "        error_file_2_matches = [ef for ef in error_files_2 if suffix.replace(\"1h\", \"2h\") in ef]\n",
    "\n",
    "\n",
    "        # Ensure both error files exist\n",
    "        if not error_file_1_matches or not error_file_2_matches:\n",
    "            print(f\"Error: Missing error file for suffix {suffix}. Skipping...\")\n",
    "            continue  # Skip this group if any file is missing\n",
    "\n",
    "        error_file_1 = error_file_1_matches[0]\n",
    "        error_file_2 = error_file_2_matches[0]\n",
    "\n",
    "        # Read values and errors\n",
    "        n, n_prime = read_values_and_errors(n_file, n_prime_file)\n",
    "        dn, dn_prime = read_values_and_errors(error_file_1, error_file_2)\n",
    "\n",
    "        # Calculate the denominator (2n + n')\n",
    "        denominator = 2 * n + n_prime\n",
    "\n",
    "        # Calculate the individual terms in the formula\n",
    "        term1 = (dn / n) ** 2\n",
    "        term2 = (dn_prime / denominator) ** 2\n",
    "\n",
    "        # Calculate the final error squared\n",
    "        final_error_squared = term1 + term2\n",
    "\n",
    "        # Append the final error (squared)\n",
    "        final_errors.append((suffix, final_error_squared))\n",
    "    \n",
    "    return final_errors\n",
    "\n",
    "\n",
    "# Example Usage\n",
    "n_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\"]\n",
    "n_prime_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\"]\n",
    "\n",
    "n_error_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\"]\n",
    "n_prime_error_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\"]\n",
    "\n",
    "# Group files by their suffix\n",
    "groups = group_files_by_suffix(n_files, n_prime_files)\n",
    "\n",
    "# Calculate final errors\n",
    "final_errors = calculate_final_error(groups, n_error_files, n_prime_error_files)\n",
    "\n",
    "# Print the results\n",
    "for suffix, error in final_errors:\n",
    "    print(f\"Final error squared for group {suffix}: {error}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "3d088c7d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Final error squared for group 1hee1: 0.0009358969927549031\n",
      "Final error squared for group 1hee2: 0.0009602182987284052\n",
      "Final error squared for group 1hee3: 0.0010040051546537413\n",
      "Final error squared for group 1hbb7: 0.0007453882260237354\n",
      "Final error squared for group 1hbb8: 0.0006480806230196539\n",
      "Final error squared for group 1hbb9: 0.0008670649692484634\n",
      "Final error squared for group 1hbe4: 0.0006282115445206181\n",
      "Final error squared for group 1hbe5: 0.0005910793580087481\n",
      "Final error squared for group 1hbe6: 0.0007130068165834612\n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "\n",
    "# Function to read values and errors\n",
    "def read_values_and_errors(file1, file2):\n",
    "    \"\"\"\n",
    "    Reads a pair of values from two files and returns the values as floats.\n",
    "    \"\"\"\n",
    "    with open(file1, 'r') as f1, open(file2, 'r') as f2:\n",
    "        value1 = float(f1.read().strip())\n",
    "        value2 = float(f2.read().strip())\n",
    "    return value1, value2\n",
    "\n",
    "# Group files by their suffix (e.g., \"hee1\")\n",
    "def group_files_by_suffix(file_list_1, file_list_2):\n",
    "    \"\"\"\n",
    "    Groups files based on their shared suffix (e.g., \"hee1\").\n",
    "    Assumes filenames follow the format N_<group>.txt.\n",
    "    \"\"\"\n",
    "    groups = {}\n",
    "\n",
    "    for f1, f2 in zip(file_list_1, file_list_2):\n",
    "        # Extract the shared suffix (e.g., \"hee1\")\n",
    "        suffix = f1.split('_')[1].replace('.txt', '')  # Extract the part after '_'\n",
    "        groups[suffix] = {\"file1\": f1, \"file2\": f2}\n",
    "    \n",
    "    return groups\n",
    "\n",
    "# Function to calculate the final error\n",
    "def calculate_final_error(groups, error_files_1, error_files_2):\n",
    "    \"\"\"\n",
    "    Calculates the final error using the formula:\n",
    "    (\\delta_\\epsilon / \\epsilon)^2 = (\\delta_n / n)^2 + (\\delta_{2n + n'}) / (2n + n')^2\n",
    "    \"\"\"\n",
    "    final_errors = []\n",
    "\n",
    "    for suffix, files in groups.items():\n",
    "        # Get the filenames for n and n' files\n",
    "        n_file = files[\"file1\"]  # e.g., N_1hee1.txt\n",
    "        n_prime_file = files[\"file2\"]  # e.g., N_2hee1.txt\n",
    "\n",
    "        # Match error files based on file structure\n",
    "        error_file_1_matches = [ef for ef in error_files_1 if suffix in ef]\n",
    "        error_file_2_matches = [ef for ef in error_files_2 if suffix.replace(\"1h\", \"2h\") in ef]\n",
    "\n",
    "\n",
    "        # Ensure both error files exist\n",
    "        if not error_file_1_matches or not error_file_2_matches:\n",
    "            print(f\"Error: Missing error file for suffix {suffix}. Skipping...\")\n",
    "            continue  # Skip this group if any file is missing\n",
    "\n",
    "        error_file_1 = error_file_1_matches[0]\n",
    "        error_file_2 = error_file_2_matches[0]\n",
    "\n",
    "        # Read values and errors\n",
    "        n, n_prime = read_values_and_errors(n_file, n_prime_file)\n",
    "        dn, dn_prime = read_values_and_errors(error_file_1, error_file_2)\n",
    "\n",
    "        # Calculate the denominator (2n + n')\n",
    "        denominator = 2 * n + n_prime\n",
    "\n",
    "        # Calculate the individual terms in the formula\n",
    "        term1 = (dn / n) ** 2\n",
    "        term2 = (dn_prime / denominator) ** 2\n",
    "\n",
    "        # Calculate the final error squared\n",
    "        final_error_squared = term1 + term2\n",
    "\n",
    "        # Append the final error (squared)\n",
    "        final_errors.append((suffix, final_error_squared))\n",
    "    \n",
    "    return final_errors\n",
    "\n",
    "\n",
    "# Example Usage\n",
    "n_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\",\"N_1hbb7.txt\",\"N_1hbb8.txt\",\"N_1hbb9.txt\",\"N_1hbe4.txt\",\"N_1hbe5.txt\",\"N_1hbe6.txt\"]\n",
    "n_prime_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\",\"N_2hbb7.txt\",\"N_2hbb8.txt\",\"N_2hbb9.txt\",\"N_2hbe4.txt\",\"N_2hbe5.txt\",\"N_2hbe6.txt\"]\n",
    "\n",
    "n_error_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\",\"eN_1hbb7.txt\",\"eN_1hbb8.txt\",\"eN_1hbb9.txt\",\"eN_1hbe4.txt\",\"eN_1hbe5.txt\",\"eN_1hbe6.txt\"]\n",
    "n_prime_error_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\",\"eN_2hbb7.txt\",\"eN_2hbb8.txt\",\"eN_2hbb9.txt\",\"eN_2hbe4.txt\",\"eN_2hbe5.txt\",\"eN_2hbe6.txt\"]\n",
    "\n",
    "# Group files by their suffix\n",
    "groups = group_files_by_suffix(n_files, n_prime_files)\n",
    "\n",
    "# Calculate final errors\n",
    "final_errors = calculate_final_error(groups, n_error_files, n_prime_error_files)\n",
    "\n",
    "# Print the results\n",
    "for suffix, error in final_errors:\n",
    "    print(f\"Final error squared for group {suffix}: {error}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "058e3257",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Final error squared for group 1Iee1: 0.001718839761879635\n",
      "Final error squared for group 1Iee2: 0.001518635853659169\n",
      "Final error squared for group 1Iee3: 0.0036654019375770815\n",
      "Final error squared for group 1Ibb9: 0.0018153923658068268\n",
      "Final error squared for group 1Ibb10: 0.0019311077312886911\n",
      "Final error squared for group 1Ibb11: 0.0019421741741463172\n",
      "Final error squared for group 1Ibe4: 0.0009419450653309044\n",
      "Final error squared for group 1Ibe5: 0.0010270575515952673\n",
      "Final error squared for group 1Ibe6: 0.001191166917400971\n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "\n",
    "# Function to read values and errors\n",
    "def read_values_and_errors(file1, file2):\n",
    "    \"\"\"\n",
    "    Reads a pair of values from two files and returns the values as floats.\n",
    "    \"\"\"\n",
    "    with open(file1, 'r') as f1, open(file2, 'r') as f2:\n",
    "        value1 = float(f1.read().strip())\n",
    "        value2 = float(f2.read().strip())\n",
    "    return value1, value2\n",
    "\n",
    "# Group files by their suffix (e.g., \"hee1\")\n",
    "def group_files_by_suffix(file_list_1, file_list_2):\n",
    "    \"\"\"\n",
    "    Groups files based on their shared suffix (e.g., \"hee1\").\n",
    "    Assumes filenames follow the format N_<group>.txt.\n",
    "    \"\"\"\n",
    "    groups = {}\n",
    "\n",
    "    for f1, f2 in zip(file_list_1, file_list_2):\n",
    "        # Extract the shared suffix (e.g., \"hee1\")\n",
    "        suffix = f1.split('_')[1].replace('.txt', '')  # Extract the part after '_'\n",
    "        groups[suffix] = {\"file1\": f1, \"file2\": f2}\n",
    "    \n",
    "    return groups\n",
    "\n",
    "# Function to calculate the final error\n",
    "def calculate_final_error(groups, error_files_1, error_files_2):\n",
    "    \"\"\"\n",
    "    Calculates the final error using the formula:\n",
    "    (\\delta_\\epsilon / \\epsilon)^2 = (\\delta_n / n)^2 + (\\delta_{2n + n'}) / (2n + n')^2\n",
    "    \"\"\"\n",
    "    final_errors = []\n",
    "\n",
    "    for suffix, files in groups.items():\n",
    "        # Get the filenames for n and n' files\n",
    "        n_file = files[\"file1\"]  # e.g., N_1hee1.txt\n",
    "        n_prime_file = files[\"file2\"]  # e.g., N_2hee1.txt\n",
    "\n",
    "        # Match error files based on file structure\n",
    "        error_file_1_matches = [ef for ef in error_files_1 if suffix in ef]\n",
    "        error_file_2_matches = [ef for ef in error_files_2 if suffix.replace(\"1I\", \"2I\") in ef]\n",
    "\n",
    "\n",
    "        # Ensure both error files exist\n",
    "        if not error_file_1_matches or not error_file_2_matches:\n",
    "            print(f\"Error: Missing error file for suffix {suffix}. Skipping...\")\n",
    "            continue  # Skip this group if any file is missing\n",
    "\n",
    "        error_file_1 = error_file_1_matches[0]\n",
    "        error_file_2 = error_file_2_matches[0]\n",
    "\n",
    "        # Read values and errors\n",
    "        n, n_prime = read_values_and_errors(n_file, n_prime_file)\n",
    "        dn, dn_prime = read_values_and_errors(error_file_1, error_file_2)\n",
    "\n",
    "        # Calculate the denominator (2n + n')\n",
    "        denominator = 2 * n + n_prime\n",
    "\n",
    "        # Calculate the individual terms in the formula\n",
    "        term1 = (dn / n) ** 2\n",
    "        term2 = (dn_prime / denominator) ** 2\n",
    "\n",
    "        # Calculate the final error squared\n",
    "        final_error_squared = term1 + term2\n",
    "\n",
    "        # Append the final error (squared)\n",
    "        final_errors.append((suffix, final_error_squared))\n",
    "    \n",
    "    return final_errors\n",
    "\n",
    "\n",
    "# Example Usage\n",
    "n_files = [\"N_1Iee1.txt\", \"N_1Iee2.txt\", \"N_1Iee3.txt\",\"N_1Ibb9.txt\",\"N_1Ibb10.txt\",\"N_1Ibb11.txt\",\"N_1Ibe4.txt\",\"N_1Ibe5.txt\",\"N_1Ibe6.txt\"]\n",
    "n_prime_files = [\"N_2Iee1.txt\", \"N_2Iee2.txt\", \"N_2Iee3.txt\",\"N_2Ibb9.txt\",\"N_2Ibb10.txt\",\"N_2Ibb11.txt\",\"N_2Ibe4.txt\",\"N_2Ibe5.txt\",\"N_2Ibe6.txt\"]\n",
    "\n",
    "n_error_files = [\"eN_1Iee1.txt\", \"eN_1Iee2.txt\", \"eN_1Iee3.txt\",\"eN_1Ibb9.txt\",\"eN_1Ibb10.txt\",\"eN_1Ibb11.txt\",\"eN_1Ibe4.txt\",\"eN_1Ibe5.txt\",\"eN_1Ibe6.txt\"]\n",
    "n_prime_error_files = [\"eN_2Iee1.txt\", \"eN_2Iee2.txt\", \"eN_2Iee3.txt\",\"eN_2Ibb9.txt\",\"eN_2Ibb10.txt\",\"eN_2Ibb11.txt\",\"eN_2Ibe4.txt\",\"eN_2Ibe5.txt\",\"eN_2Ibe6.txt\"]\n",
    "\n",
    "# Group files by their suffix\n",
    "groups = group_files_by_suffix(n_files, n_prime_files)\n",
    "\n",
    "# Calculate final errors\n",
    "final_errors = calculate_final_error(groups, n_error_files, n_prime_error_files)\n",
    "\n",
    "# Print the results\n",
    "for suffix, error in final_errors:\n",
    "    print(f\"Final error squared for group {suffix}: {error}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "c82b4c74",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.00264 0.00247 0.001366\n",
      "0.00156 0.00161 0.0019000000000000002\n",
      "0.00255 0.0025700000000000002 0.0028\n",
      "*******\n",
      "4.2162000000000004e-07 5.5358e-07 9.6669e-07\n",
      "4.3467999999999997e-07 5.9759e-07 9.9927e-07\n",
      "7.5935e-07 1.3403400000000002e-06 1.70057e-06\n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "erepEE_1 = 0.00093+0.00171\n",
    "erepEE_2 = 0.00096+0.00151\n",
    "erepEE_3 = 0.00100+0.000366\n",
    "erepBE_1 = 0.00062+0.00094\n",
    "erepBE_2 = 0.00059+0.00102\n",
    "erepBE_3 = 0.00071+0.00119\n",
    "erepBB_1 = 0.00074+0.00181\n",
    "erepBB_2 = 0.00064+0.00193\n",
    "erepBB_3 = 0.00086+0.00194\n",
    "print(erepEE_1,erepEE_2,erepEE_3)\n",
    "print(erepBE_1,erepBE_2,erepBE_3)\n",
    "print(erepBB_1,erepBB_2,erepBB_3)\n",
    "print(\"*******\")\n",
    "ernEE_1 = (2.5243+1.6919)*math.pow(10,-7)\n",
    "ernEE_2 = (3.0788+2.4570)*math.pow(10,-7)\n",
    "ernEE_3 = (5.1076+4.5593)*math.pow(10,-7)\n",
    "ernBE_1 = (2.2768+2.0700)*math.pow(10,-7)\n",
    "ernBE_2 = (2.8715+3.1044)*math.pow(10,-7)\n",
    "ernBE_3 = (4.5402+5.4525)*math.pow(10,-7)\n",
    "ernBB_1 = (3.9392+3.6543)*math.pow(10,-7)\n",
    "ernBB_2 = (4.7655+8.6379)*math.pow(10,-7)\n",
    "ernBB_3 = (8.0408+8.9649)*math.pow(10,-7)\n",
    "print(ernEE_1,ernEE_2,ernEE_3)\n",
    "print(ernBE_1,ernBE_2,ernBE_3)\n",
    "print(ernBB_1,ernBB_2,ernBB_3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "d62196a3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Result for set 1: 2.5243262710218377e-07\n",
      "Result for set 2: 3.07886655752429e-07\n",
      "Result for set 3: 5.107658367858631e-07\n",
      "Result for set 4: 3.93924588518439e-07\n",
      "Result for set 5: 4.765530969209052e-07\n",
      "Result for set 6: 8.040850419286541e-07\n",
      "Result for set 7: 2.2768434023623824e-07\n",
      "Result for set 8: 2.871517843938897e-07\n",
      "Result for set 9: 4.540252989368545e-07\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "\n",
    "# Helper function to read a value and its uncertainty from a file\n",
    "def read_value_and_uncertainty(filename, default_uncertainty=1.0):\n",
    "    try:\n",
    "        with open(filename, 'r') as file:\n",
    "            # Read the first line and attempt to split into one value\n",
    "            line = file.readline().strip()\n",
    "\n",
    "            # Skip empty lines\n",
    "            if not line:\n",
    "                raise ValueError(f\"Empty line in file: {filename}\")\n",
    "            \n",
    "            # Only one value is expected\n",
    "            value = float(line)\n",
    "            return value, default_uncertainty\n",
    "            \n",
    "    except Exception as e:\n",
    "        print(f\"Error reading {filename}: {e}\")\n",
    "        return None, None  # Return None to indicate a problem\n",
    "\n",
    "# Function to calculate epsilon\n",
    "def calculate_epsilon(N1, N2):\n",
    "    return (2 * N2) / (2 * N2 + N1)\n",
    "\n",
    "# Function to calculate (delta_N / N)^2\n",
    "def calculate_delta_N_over_N_squared(n1_file, n2_file, n1_error_file, n2_error_file):\n",
    "    results = []  # Initialize an empty list to store results\n",
    "\n",
    "    for i in range(len(n1_file)):\n",
    "        # Read N1 and N2 values and their uncertainties\n",
    "        N1, delta_N1 = read_value_and_uncertainty(n1_file[i])\n",
    "        N2, delta_N2 = read_value_and_uncertainty(n2_file[i])\n",
    "\n",
    "        if N1 is None or N2 is None:\n",
    "            print(f\"Skipping calculation for set {i+1} due to missing or invalid data.\")\n",
    "            continue\n",
    "\n",
    "        # Assume constant uncertainties for the N1 and N2 files (e.g., default value of 1.0)\n",
    "        _, delta_N1_error = read_value_and_uncertainty(n1_error_file[i], default_uncertainty=1.0)\n",
    "        _, delta_N2_error = read_value_and_uncertainty(n2_error_file[i], default_uncertainty=1.0)\n",
    "\n",
    "        if delta_N1_error is None or delta_N2_error is None:\n",
    "            print(f\"Skipping calculation for set {i+1} due to missing uncertainties.\")\n",
    "            continue\n",
    "\n",
    "        # Calculate epsilon\n",
    "        epsilon = calculate_epsilon(N1, N2)\n",
    "\n",
    "        # Calculate relative uncertainties\n",
    "        delta_N2_over_N2 = delta_N2 / N2\n",
    "\n",
    "        # Propagate uncertainty through epsilon formula\n",
    "        delta_epsilon = np.abs(2 * N2 / (2 * N2 + N1)**2) * delta_N1 + np.abs(-2 / (2 * N2 + N1)) * delta_N2\n",
    "        term2 = delta_epsilon / (2 * epsilon * (1 - epsilon))\n",
    "\n",
    "        # Calculate (delta_N / N)^2\n",
    "        delta_N_over_N_squared = delta_N2_over_N2**2 + term2**2\n",
    "        results.append(delta_N_over_N_squared)\n",
    "\n",
    "    return results\n",
    "\n",
    "# Example usage\n",
    "n1_file = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\", \"N_1hbb7.txt\", \"N_1hbb8.txt\", \"N_1hbb9.txt\", \"N_1hbe4.txt\", \"N_1hbe5.txt\", \"N_1hbe6.txt\"]\n",
    "n2_file = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\", \"N_2hbb7.txt\", \"N_2hbb8.txt\", \"N_2hbb9.txt\", \"N_2hbe4.txt\", \"N_2hbe5.txt\", \"N_2hbe6.txt\"]\n",
    "n1_error_file = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\", \"eN_1hbb7.txt\", \"eN_1hbb8.txt\", \"eN_1hbb9.txt\", \"eN_1hbe4.txt\", \"eN_1hbe5.txt\", \"eN_1hbe6.txt\"]\n",
    "n2_error_file = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\", \"eN_2hbb7.txt\", \"eN_2hbb8.txt\", \"eN_2hbb9.txt\", \"eN_2hbe4.txt\", \"eN_2hbe5.txt\", \"eN_2hbe6.txt\"]\n",
    "\n",
    "# Loop through all the files and calculate the result for each pair\n",
    "results = calculate_delta_N_over_N_squared(n1_file, n2_file, n1_error_file, n2_error_file)\n",
    "\n",
    "# Print results\n",
    "for i, result in enumerate(results):\n",
    "    print(f\"Result for set {i+1}: {result}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "b709f28b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Result for set 1: 1.691963323786033e-07\n",
      "Result for set 2: 2.4570905761608477e-07\n",
      "Result for set 3: 4.559327251164106e-07\n",
      "Result for set 4: 3.654311045416467e-07\n",
      "Result for set 5: 8.637976100394578e-07\n",
      "Result for set 6: 8.964979968264938e-07\n",
      "Result for set 7: 2.0700345936944278e-07\n",
      "Result for set 8: 3.1044386465338073e-07\n",
      "Result for set 9: 5.452548059500491e-07\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "\n",
    "# Helper function to read a value and its uncertainty from a file\n",
    "def read_value_and_uncertainty(filename, default_uncertainty=1.0):\n",
    "    try:\n",
    "        with open(filename, 'r') as file:\n",
    "            # Read the first line and attempt to split into one value\n",
    "            line = file.readline().strip()\n",
    "\n",
    "            # Skip empty lines\n",
    "            if not line:\n",
    "                raise ValueError(f\"Empty line in file: {filename}\")\n",
    "            \n",
    "            # Only one value is expected\n",
    "            value = float(line)\n",
    "            return value, default_uncertainty\n",
    "            \n",
    "    except Exception as e:\n",
    "        print(f\"Error reading {filename}: {e}\")\n",
    "        return None, None  # Return None to indicate a problem\n",
    "\n",
    "# Function to calculate epsilon\n",
    "def calculate_epsilon(N1, N2):\n",
    "    return (2 * N2) / (2 * N2 + N1)\n",
    "\n",
    "# Function to calculate (delta_N / N)^2\n",
    "def calculate_delta_N_over_N_squared(n1_file, n2_file, n1_error_file, n2_error_file):\n",
    "    results = []  # Initialize an empty list to store results\n",
    "\n",
    "    for i in range(len(n1_file)):\n",
    "        # Read N1 and N2 values and their uncertainties\n",
    "        N1, delta_N1 = read_value_and_uncertainty(n1_file[i])\n",
    "        N2, delta_N2 = read_value_and_uncertainty(n2_file[i])\n",
    "\n",
    "        if N1 is None or N2 is None:\n",
    "            print(f\"Skipping calculation for set {i+1} due to missing or invalid data.\")\n",
    "            continue\n",
    "\n",
    "        # Assume constant uncertainties for the N1 and N2 files (e.g., default value of 1.0)\n",
    "        _, delta_N1_error = read_value_and_uncertainty(n1_error_file[i], default_uncertainty=1.0)\n",
    "        _, delta_N2_error = read_value_and_uncertainty(n2_error_file[i], default_uncertainty=1.0)\n",
    "\n",
    "        if delta_N1_error is None or delta_N2_error is None:\n",
    "            print(f\"Skipping calculation for set {i+1} due to missing uncertainties.\")\n",
    "            continue\n",
    "\n",
    "        # Calculate epsilon\n",
    "        epsilon = calculate_epsilon(N1, N2)\n",
    "\n",
    "        # Calculate relative uncertainties\n",
    "        delta_N2_over_N2 = delta_N2 / N2\n",
    "\n",
    "        # Propagate uncertainty through epsilon formula\n",
    "        delta_epsilon = np.abs(2 * N2 / (2 * N2 + N1)**2) * delta_N1 + np.abs(-2 / (2 * N2 + N1)) * delta_N2\n",
    "        term2 = delta_epsilon / (2 * epsilon * (1 - epsilon))\n",
    "\n",
    "        # Calculate (delta_N / N)^2\n",
    "        delta_N_over_N_squared = delta_N2_over_N2**2 + term2**2\n",
    "        results.append(delta_N_over_N_squared)\n",
    "\n",
    "    return results\n",
    "\n",
    "# Example usage\n",
    "n1_file = [\"N_1Iee1.txt\", \"N_1Iee2.txt\", \"N_1Iee3.txt\", \"N_1Ibb9.txt\", \"N_1Ibb10.txt\", \"N_1Ibb11.txt\", \"N_1Ibe4.txt\", \"N_1Ibe5.txt\", \"N_1Ibe6.txt\"]\n",
    "n2_file = [\"N_2Iee1.txt\", \"N_2Iee2.txt\", \"N_2Iee3.txt\", \"N_2Ibb9.txt\", \"N_2Ibb10.txt\", \"N_2Ibb11.txt\", \"N_2Ibe4.txt\", \"N_2Ibe5.txt\", \"N_2Ibe6.txt\"]\n",
    "n1_error_file = [\"eN_1Iee1.txt\", \"eN_1Iee2.txt\", \"eN_1Iee3.txt\", \"eN_1Ibb9.txt\", \"eN_1Ibb10.txt\", \"eN_1Ibb11.txt\", \"eN_1Ibe4.txt\", \"eN_1Ibe5.txt\", \"eN_1Ibe6.txt\"]\n",
    "n2_error_file = [\"eN_2Iee1.txt\", \"eN_2Iee2.txt\", \"eN_2Iee3.txt\", \"eN_2Ibb9.txt\", \"eN_2Ibb10.txt\", \"eN_2Ibb11.txt\", \"eN_2Ibe4.txt\", \"eN_2Ibe5.txt\", \"eN_2Ibe6.txt\"]\n",
    "\n",
    "# Loop through all the files and calculate the result for each pair\n",
    "results = calculate_delta_N_over_N_squared(n1_file, n2_file, n1_error_file, n2_error_file)\n",
    "\n",
    "# Print results\n",
    "for i, result in enumerate(results):\n",
    "    print(f\"Result for set {i+1}: {result}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "a2f26ac2",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'np' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m/tmp/ipykernel_471/3819762956.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     29\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     30\u001b[0m \u001b[0;31m# Load all input data for the first set\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 31\u001b[0;31m \u001b[0mN1\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mload_data\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mN1_files\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     32\u001b[0m \u001b[0mN2\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mload_data\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mN2_files\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     33\u001b[0m \u001b[0mN1_prime\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mload_data\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mN1_prime_files\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/tmp/ipykernel_471/3819762956.py\u001b[0m in \u001b[0;36mload_data\u001b[0;34m(file_list)\u001b[0m\n\u001b[1;32m     16\u001b[0m \u001b[0;31m# Load data from text files\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     17\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mload_data\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 18\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mloadtxt\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mfile\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mfile_list\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     19\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     20\u001b[0m \u001b[0;31m# File names for inputs\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/tmp/ipykernel_471/3819762956.py\u001b[0m in \u001b[0;36m<listcomp>\u001b[0;34m(.0)\u001b[0m\n\u001b[1;32m     16\u001b[0m \u001b[0;31m# Load data from text files\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     17\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mload_data\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 18\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mloadtxt\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mfile\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mfile_list\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     19\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     20\u001b[0m \u001b[0;31m# File names for inputs\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mNameError\u001b[0m: name 'np' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) ** 2) / (4 * N2)\n",
    "    term3 = ((2 * N2 + N1) * (2 * N2_prime + N1_prime)) / (4 * N2 * N2_prime)\n",
    "    return term1 * term2 * term3\n",
    "\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = ((4 * delta_N2 ** 2 + delta_N1 ** 2) / (2 * N2 + N1)) ** 2\n",
    "    term4 = ((4 * delta_N2_prime ** 2 + delta_N1_prime ** 2) / (2 * N2_prime + N1_prime)) ** 2\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "# Load data from text files\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\"]\n",
    "N2_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\"]\n",
    "N1_prime_files = [\"N_1Iee1.txt\", \"N_1Iee2.txt\", \"N_1Iee3.txt\"]\n",
    "N2_prime_files = [\"N_2Iee1.txt\", \"N_2Iee2.txt\", \"N_2Iee3.txt\"]\n",
    "delta_N1_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\"]\n",
    "delta_N2_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Iee1.txt\", \"eN_1Iee2.txt\", \"eN_1Iee3.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Iee1.txt\", \"eN_2Iee2.txt\", \"eN_2Iee3.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.018*0.31)\n",
    "constant_value_2 =  0.000001582 \n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "\n",
    "# File names for inputs (second set of data)\n",
    "N1_files2 = [\"N_1hbb7.txt\", \"N_1hbb8.txt\", \"N_1hbb9.txt\"] \n",
    "N2_files2 = [\"N_2hbb7.txt\", \"N_2hbb8.txt\", \"N_2hbb9.txt\"]\n",
    "N1_prime_files2 = [\"N_1Ibb9.txt\", \"N_1Ibb10.txt\", \"N_1Ibb11.txt\"]\n",
    "N2_prime_files2 = [\"N_2Ibb9.txt\", \"N_2Ibb10.txt\", \"N_2Ibb11.txt\"]\n",
    "delta_N1_files2 = [\"eN_1hbb7.txt\", \"eN_1hbb8.txt\", \"eN_1hbb9.txt\"]\n",
    "delta_N2_files2 = [\"eN_2hbb7.txt\", \"eN_2hbb8.txt\", \"eN_2hbb9.txt\"]\n",
    "delta_N1_prime_files2 = [\"eN_1Ibb9.txt\", \"eN_1Ibb10.txt\", \"eN_1Ibb11.txt\"]\n",
    "delta_N2_prime_files2 = [\"eN_2Ibb9.txt\", \"eN_2Ibb10.txt\", \"eN_2Ibb11.txt\"]\n",
    "\n",
    "# Load all input data for the second set\n",
    "N1_alt = load_data(N1_files2)\n",
    "N2_alt = load_data(N2_files2)\n",
    "N1_prime_alt = load_data(N1_prime_files2)\n",
    "N2_prime_alt = load_data(N2_prime_files2)\n",
    "delta_N1_alt = load_data(delta_N1_files2)\n",
    "delta_N2_alt = load_data(delta_N2_files2)\n",
    "delta_N1_prime_alt = load_data(delta_N1_prime_files2)\n",
    "delta_N2_prime_alt = load_data(delta_N2_prime_files2)\n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the second set of inputs\n",
    "L_values2 = []\n",
    "delta_L_over_L_squared_values2 = []\n",
    "for i in range(len(N1_alt)):\n",
    "    L = calculate_L(N1_alt[i], N2_alt[i], N1_prime_alt[i], N2_prime_alt[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1_alt[i], N2_alt[i], N1_prime_alt[i], N2_prime_alt[i], delta_N1_alt[i], delta_N2_alt[i], delta_N1_prime_alt[i], delta_N2_prime_alt[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values2.append(L)\n",
    "    delta_L_over_L_squared_values2.append(delta_L_squared)\n",
    "\n",
    "# File names for inputs (third set of data)\n",
    "N1_files3 = [\"N_1hbe4.txt\", \"N_1hbe5.txt\", \"N_1hbe6.txt\"]\n",
    "N2_files3 = [\"N_2hbe4.txt\", \"N_2hbe5.txt\", \"N_2hbe6.txt\"]\n",
    "N1_prime_files3 = [\"N_1Ibe4.txt\", \"N_1Ibe5.txt\", \"N_1Ibe6.txt\"]\n",
    "N2_prime_files3 = [\"N_2Ibe4.txt\", \"N_2Ibe5.txt\", \"N_2Ibe6.txt\"]\n",
    "delta_N1_files3 = [\"eN_1hbe4.txt\", \"eN_1hbe5.txt\", \"eN_1hbe6.txt\"]\n",
    "delta_N2_files3 = [\"eN_2hbe4.txt\", \"eN_2hbe5.txt\", \"eN_2hbe6.txt\"]\n",
    "delta_N1_prime_files3 = [\"eN_1Ibe4.txt\", \"eN_1Ibe5.txt\", \"eN_1Ibe6.txt\"]\n",
    "delta_N2_prime_files3 = [\"eN_2Ibe4.txt\", \"eN_2Ibe5.txt\", \"eN_2Ibe6.txt\"]\n",
    "\n",
    "# Load all input data for the third set\n",
    "N1_altt = load_data(N1_files3)\n",
    "N2_altt = load_data(N2_files3)\n",
    "N1_prime_altt = load_data(N1_prime_files3)\n",
    "N2_prime_altt = load_data(N2_prime_files3)\n",
    "delta_N1_altt = load_data(delta_N1_files3)\n",
    "delta_N2_altt = load_data(delta_N2_files3)\n",
    "delta_N1_prime_altt = load_data(delta_N1_prime_files3)\n",
    "delta_N2_prime_altt = load_data(delta_N2_prime_files3)\n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the third set of inputs\n",
    "L_values3 = []\n",
    "delta_L_over_L_squared_values3 = []\n",
    "for i in range(len(N1_altt)):\n",
    "    L = calculate_L(N1_altt[i], N2_altt[i], N1_prime_altt[i], N2_prime_altt[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1_altt[i], N2_altt[i], N1_prime_altt[i], N2_prime_altt[i], delta_N1_altt[i], delta_N2_altt[i], delta_N1_prime_altt[i], delta_N2_prime_altt[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values3.append(L)\n",
    "    delta_L_over_L_squared_values3.append(delta_L_squared)\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 42, 83\n",
    "x_bin_start3, x_bin_end3 = 83, 120\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_EE\",L_values1)\n",
    "print(\"errorlumi_EE\",delta_L_over_L_squared_values1)\n",
    "print(\"lumi_BB\",L_values2)\n",
    "print(\"errorlumi_BB\",delta_L_over_L_squared_values2)\n",
    "print(\"lumi_BE\",L_values3)\n",
    "print(\"errorlumi_BE\",delta_L_over_L_squared_values3)\n",
    "a = L_values1[0]+L_values2[0]+L_values3[0]\n",
    "b = L_values1[1]+L_values2[1]+L_values3[1]\n",
    "c = L_values1[2]+L_values2[2]+L_values3[2]\n",
    "alll = [a,b,c]\n",
    "da = delta_L_over_L_squared_values1[0]+delta_L_over_L_squared_values2[0]+delta_L_over_L_squared_values3[0]\n",
    "db = delta_L_over_L_squared_values1[1]+delta_L_over_L_squared_values2[1]+delta_L_over_L_squared_values3[1]\n",
    "dc = delta_L_over_L_squared_values1[2]+delta_L_over_L_squared_values2[2]+delta_L_over_L_squared_values3[2]\n",
    "allle = [da,db,dc]\n",
    "lbril_values = [116086.333 , 100081.51 , 93398.989]\n",
    "print(\"lumi_tot\",alll )\n",
    "print(\"erlumi_tot\",allle )\n",
    "\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.errorbar(lumisec_midpoints, alll ,yerr=allle , fmt='o', color='red',  capsize=5)\n",
    "plt.errorbar(lumisec_midpoints, lbril_values , fmt='o', color='black',  capsize=5)\n",
    "\n",
    "# plt.errorbar(lumisec_midpoints, L_values1, yerr=delta_L_over_L_squared_values1, fmt='o', color='black',  capsize=5)\n",
    "# plt.errorbar(lumisec_midpoints, L_values2, yerr=delta_L_over_L_squared_values2, fmt='o', color='blue',  capsize=5)\n",
    "# plt.errorbar(lumisec_midpoints, L_values3, yerr=delta_L_over_L_squared_values3, fmt='o', color='red',  capsize=5)\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"L\")\n",
    "plt.title(\"L vs Lumisec\")\n",
    "plt.grid()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "70aacf02",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import uproot\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) *(2 * N2_prime + N1_prime)) / (4*N2 * N2_prime)\n",
    "    term3 = ((2 * N2 + N1) **2) / (4*N2)\n",
    "    return term1 * term2 * term3\n",
    "\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = (4 * (delta_N2) ** 2 + (delta_N1) ** 2) / ((2 * N2 + N1) ** 2)\n",
    "    term4 = (4 * (delta_N2_prime) ** 2 + (delta_N1_prime) ** 2) / ((2 * N2_prime + N1_prime) ** 2)\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "# Load data from text files\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\"]\n",
    "N2_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\"]\n",
    "N1_prime_files = [\"N_1Iee1.txt\", \"N_1Iee2.txt\", \"N_1Iee3.txt\"]\n",
    "N2_prime_files = [\"N_2Iee1.txt\", \"N_2Iee2.txt\", \"N_2Iee3.txt\"]\n",
    "delta_N1_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\"]\n",
    "delta_N2_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Iee1.txt\", \"eN_1Iee2.txt\", \"eN_1Iee3.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Iee1.txt\", \"eN_2Iee2.txt\", \"eN_2Iee3.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.018*0.106)\n",
    "constant_value_2 =  0.00000369\n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 42, 83\n",
    "x_bin_start3, x_bin_end3 = 83, 120\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_EE\",L_values1)\n",
    "print(\"errorlumi_EE\",delta_L_over_L_squared_values1)\n",
    "\n",
    "rat = [lbril_values[0]/L_values1[0], lbril_values[1]/L_values1[1] , lbril_values[2]/L_values1[2]]\n",
    "lbril_values = [116086.333 , 100081.51 , 93398.989]\n",
    "\n",
    "print(\"bril\",lbril_values)\n",
    "\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.errorbar(lumisec_midpoints, rat , fmt='o', color='red',  capsize=5,label=\"lumi_bril/lumi_EE\")\n",
    "\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"lumi_bril/lumi_EE\")\n",
    "plt.legend()\n",
    "plt.grid()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "d0bf691c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lumi_EE [111136.43349056435, 95611.12468628376, 79060.80995194193]\n",
      "errorlumi_EE [61.31921399483007, 43.95399489098228, 41.4105239474791]\n",
      "bril [114618.486, 97972.294, 81904.476]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x720 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import uproot\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) **2 )*((2 * N2_prime + N1_prime)**2) / (16*N2 * (N2_prime)**2)\n",
    "    term3 = ((2 * N2 + N1)*(2 * N2_prime + N1_prime)) / (4*N2* N2_prime)\n",
    "    return term1 * term2 * term3\n",
    "\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = ((4 * delta_N2 ** 2 + delta_N1 ** 2) / (2 * N2 + N1)) ** 2\n",
    "    term4 = ((4 * delta_N2_prime ** 2 + delta_N1_prime ** 2) / (2 * N2_prime + N1_prime)) ** 2\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "# Load data from text files\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\"]\n",
    "N2_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\"]\n",
    "N1_prime_files = [\"N_1Iee1.txt\", \"N_1Iee2.txt\", \"N_1Iee3.txt\"]\n",
    "N2_prime_files = [\"N_2Iee1.txt\", \"N_2Iee2.txt\", \"N_2Iee3.txt\"]\n",
    "delta_N1_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\"]\n",
    "delta_N2_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Iee1.txt\", \"eN_1Iee2.txt\", \"eN_1Iee3.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Iee1.txt\", \"eN_2Iee2.txt\", \"eN_2Iee3.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.073*0.106)\n",
    "constant_value_2 =  0.000001582 \n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 41, 81\n",
    "x_bin_start3, x_bin_end3 = 81, 119\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_EE\",L_values1)\n",
    "print(\"errorlumi_EE\",delta_L_over_L_squared_values1)\n",
    "\n",
    "lbril_values = [114618.486  , 97972.294 , 81904.476]\n",
    "rat = [lbril_values[0]/L_values1[0], lbril_values[1]/L_values1[1] , lbril_values[2]/L_values1[2]]\n",
    "print(\"bril\",lbril_values)\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "# plt.errorbar(lumisec_midpoints,L_values1  ,yerr= delta_L_over_L_squared_values1, fmt='o', color='red',  capsize=5)\n",
    "# plt.errorbar(lumisec_midpoints, lbril_values , fmt='o', color='black',  capsize=5)\n",
    "plt.errorbar(lumisec_midpoints, rat , fmt='o', color='red', capsize=5,label=\"lumi_bril/lumi_EE\")\n",
    "\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"L\")\n",
    "plt.title(\"L vs Lumisec\")\n",
    "plt.grid()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "423868c5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lumi_EE [104538.17036397796, 89200.83999217776, 73517.43533196853]\n",
      "errorlumi_EE [31.397942501345742, 24.33093260617798, 21.19294600025665]\n",
      "bril [114618.486, 97972.294, 81904.476]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x720 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import uproot\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) **2 )*((2 * N2_prime + N1_prime)**2) / (16*N2 * (N2_prime)**2)\n",
    "    term3 = ((2 * N2 + N1)*(2 * N2_prime + N1_prime)) / (4*N2* N2_prime)\n",
    "    return term1 * term2 * term3\n",
    "\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = ((4 * delta_N2 ** 2 + delta_N1 ** 2) / (2 * N2 + N1)) ** 2\n",
    "    term4 = ((4 * delta_N2_prime ** 2 + delta_N1_prime ** 2) / (2 * N2_prime + N1_prime)) ** 2\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "# Load data from text files\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hbe4.txt\", \"N_1hbe5.txt\", \"N_1hbe6.txt\"]\n",
    "N2_files = [\"N_2hbe4.txt\", \"N_2hbe5.txt\", \"N_2hbe6.txt\"]\n",
    "N1_prime_files = [\"N_1Ibe4.txt\", \"N_1Ibe5.txt\", \"N_1Ibe6.txt\"]\n",
    "N2_prime_files = [\"N_2Ibe4.txt\", \"N_2Ibe5.txt\", \"N_2Ibe6.txt\"]\n",
    "delta_N1_files = [\"eN_1hbe4.txt\", \"eN_1hbe5.txt\", \"eN_1hbe6.txt\"]\n",
    "delta_N2_files = [\"eN_2hbe4.txt\", \"eN_2hbe5.txt\", \"eN_2hbe6.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Ibe4.txt\", \"eN_1Ibe5.txt\", \"eN_1Ibe6.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Ibe4.txt\", \"eN_2Ibe5.txt\", \"eN_2Ibe6.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.073*0.112)\n",
    "constant_value_2 =  0.000001582 \n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 41, 81\n",
    "x_bin_start3, x_bin_end3 = 81, 119\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_EE\",L_values1)\n",
    "print(\"errorlumi_EE\",delta_L_over_L_squared_values1)\n",
    "\n",
    "lbril_values = [114618.486  , 97972.294 , 81904.476]\n",
    "rat = [lbril_values[0]/L_values1[0], lbril_values[1]/L_values1[1] , lbril_values[2]/L_values1[2]]\n",
    "print(\"bril\",lbril_values)\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "# plt.errorbar(lumisec_midpoints,L_values1  ,yerr= delta_L_over_L_squared_values1, fmt='o', color='red',  capsize=5)\n",
    "# plt.errorbar(lumisec_midpoints, lbril_values , fmt='o', color='black',  capsize=5)\n",
    "plt.errorbar(lumisec_midpoints, rat ,fmt='o', color='red', capsize=5,label=\"lumi_bril/lumi_EE\")\n",
    "\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"L\")\n",
    "plt.title(\"L vs Lumisec\")\n",
    "plt.grid()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "4eee652a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lumi_EE [125129.85682814714, 105982.53742888258, 88180.27290587434]\n",
      "errorlumi_EE [26.463186089330147, 19.66965497555974, 18.277960785446947]\n",
      "bril [114618.486, 97972.294, 81904.476]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x720 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import uproot\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) **2 )*((2 * N2_prime + N1_prime)**2) / (16*N2 * (N2_prime)**2)\n",
    "    term3 = ((2 * N2 + N1)*(2 * N2_prime + N1_prime)) / (4*N2* N2_prime)\n",
    "    return term1 * term2 * term3\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = ((4 * delta_N2 ** 2 + delta_N1 ** 2) / (2 * N2 + N1)) ** 2\n",
    "    term4 = ((4 * delta_N2_prime ** 2 + delta_N1_prime ** 2) / (2 * N2_prime + N1_prime)) ** 2\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "# Load data from text files\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hbb7.txt\", \"N_1hbb8.txt\", \"N_1hbb9.txt\"] \n",
    "N2_files = [\"N_2hbb7.txt\", \"N_2hbb8.txt\", \"N_2hbb9.txt\"]\n",
    "N1_prime_files = [\"N_1Ibb9.txt\", \"N_1Ibb10.txt\", \"N_1Ibb11.txt\"]\n",
    "N2_prime_files = [\"N_2Ibb9.txt\", \"N_2Ibb10.txt\", \"N_2Ibb11.txt\"]\n",
    "delta_N1_files = [\"eN_1hbb7.txt\", \"eN_1hbb8.txt\", \"eN_1hbb9.txt\"]\n",
    "delta_N2_files = [\"eN_2hbb7.txt\", \"eN_2hbb8.txt\", \"eN_2hbb9.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Ibb9.txt\", \"eN_1Ibb10.txt\", \"eN_1Ibb11.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Ibb9.txt\", \"eN_2Ibb10.txt\", \"eN_2Ibb11.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.073*0.073)\n",
    "constant_value_2 =  0.000001582 \n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 41, 81\n",
    "x_bin_start3, x_bin_end3 = 81, 119\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_EE\",L_values1)\n",
    "print(\"errorlumi_EE\",delta_L_over_L_squared_values1)\n",
    "\n",
    "lbril_values = [114618.486  , 97972.294 , 81904.476]\n",
    "rat = [lbril_values[0]/L_values1[0], lbril_values[1]/L_values1[1] , lbril_values[2]/L_values1[2]]\n",
    "print(\"bril\",lbril_values)\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "# plt.errorbar(lumisec_midpoints,L_values1  ,yerr= delta_L_over_L_squared_values1, fmt='o', color='red',  capsize=5)\n",
    "# plt.errorbar(lumisec_midpoints, lbril_values , fmt='o', color='black',  capsize=5)\n",
    "plt.errorbar(lumisec_midpoints, rat ,fmt='o', color='red', capsize=5,label=\"lumi_bril/lumi_EE\")\n",
    "\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"L\")\n",
    "plt.title(\"L vs Lumisec\")\n",
    "plt.grid()\n",
    "plt.show()\n",
    "# lumi_EE [99663.03191473045, 85530.01752005453, 70978.6528632015]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "db040765",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lumi_EE [99663.03191473045, 85530.01752005453, 70978.6528632015]\n",
      "errorlumi_EE [26.463186089330147, 19.66965497555974, 18.277960785446947]\n",
      "bril [114618.486, 97972.294, 81904.476]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x720 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) ** 2) / (4 * N2) \n",
    "    term3 = ((2 * N2 + N1) * (2 * N2_prime + N1_prime)) / (4 * N2 * N2_prime)\n",
    "    return term1 * term2 * term3\n",
    "\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = ((4 * delta_N2 ** 2 + delta_N1 ** 2) / (2 * N2 + N1)) ** 2\n",
    "    term4 = ((4 * delta_N2_prime ** 2 + delta_N1_prime ** 2) / (2 * N2_prime + N1_prime)) ** 2\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hbb7.txt\", \"N_1hbb8.txt\", \"N_1hbb9.txt\"] \n",
    "N2_files = [\"N_2hbb7.txt\", \"N_2hbb8.txt\", \"N_2hbb9.txt\"]\n",
    "N1_prime_files = [\"N_1Ibb9.txt\", \"N_1Ibb10.txt\", \"N_1Ibb11.txt\"]\n",
    "N2_prime_files = [\"N_2Ibb9.txt\", \"N_2Ibb10.txt\", \"N_2Ibb11.txt\"]\n",
    "delta_N1_files = [\"eN_1hbb7.txt\", \"eN_1hbb8.txt\", \"eN_1hbb9.txt\"]\n",
    "delta_N2_files = [\"eN_2hbb7.txt\", \"eN_2hbb8.txt\", \"eN_2hbb9.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Ibb9.txt\", \"eN_1Ibb10.txt\", \"eN_1Ibb11.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Ibb9.txt\", \"eN_2Ibb10.txt\", \"eN_2Ibb11.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.073*0.073)\n",
    "constant_value_2 =  0.000001582 \n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 41, 81\n",
    "x_bin_start3, x_bin_end3 = 81, 119\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_EE\",L_values1)\n",
    "print(\"errorlumi_EE\",delta_L_over_L_squared_values1)\n",
    "\n",
    "lbril_values = [114618.486  , 97972.294 , 81904.476]\n",
    "rat = [lbril_values[0]/L_values1[0], lbril_values[1]/L_values1[1] , lbril_values[2]/L_values1[2]]\n",
    "print(\"bril\",lbril_values)\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.errorbar(lumisec_midpoints,L_values1  ,yerr= delta_L_over_L_squared_values1, fmt='o', color='red',  capsize=5)\n",
    "plt.errorbar(lumisec_midpoints, lbril_values , fmt='o', color='black',  capsize=5)\n",
    "# plt.errorbar(lumisec_midpoints, rat ,fmt='o', color='red', capsize=5,label=\"lumi_bril/lumi_EE\")\n",
    "\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"L\")\n",
    "plt.title(\"L vs Lumisec\")\n",
    "plt.grid()\n",
    "plt.show()\n",
    "# lumi_EE [99663.03191473045, 85530.01752005453, 70978.6528632015]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "893b8440",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fa22f700",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
