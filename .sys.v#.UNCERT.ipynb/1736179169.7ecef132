{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "ada76428",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Final error squared for group 1hee1: 0.0009358969927549031\n",
      "Final error squared for group 1hee2: 0.0009602182987284052\n",
      "Final error squared for group 1hee3: 0.0010040051546537413\n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "\n",
    "# Function to read values and errors\n",
    "def read_values_and_errors(file1, file2):\n",
    "    \"\"\"\n",
    "    Reads a pair of values from two files and returns the values as floats.\n",
    "    \"\"\"\n",
    "    with open(file1, 'r') as f1, open(file2, 'r') as f2:\n",
    "        value1 = float(f1.read().strip())\n",
    "        value2 = float(f2.read().strip())\n",
    "    return value1, value2\n",
    "\n",
    "# Group files by their suffix (e.g., \"hee1\")\n",
    "def group_files_by_suffix(file_list_1, file_list_2):\n",
    "    \"\"\"\n",
    "    Groups files based on their shared suffix (e.g., \"hee1\").\n",
    "    Assumes filenames follow the format N_<group>.txt.\n",
    "    \"\"\"\n",
    "    groups = {}\n",
    "\n",
    "    for f1, f2 in zip(file_list_1, file_list_2):\n",
    "        # Extract the shared suffix (e.g., \"hee1\")\n",
    "        suffix = f1.split('_')[1].replace('.txt', '')  # Extract the part after '_'\n",
    "        groups[suffix] = {\"file1\": f1, \"file2\": f2}\n",
    "    \n",
    "    return groups\n",
    "\n",
    "# Function to calculate the final error\n",
    "def calculate_final_error(groups, error_files_1, error_files_2):\n",
    "    \"\"\"\n",
    "    Calculates the final error using the formula:\n",
    "    (\\delta_\\epsilon / \\epsilon)^2 = (\\delta_n / n)^2 + (\\delta_{2n + n'}) / (2n + n')^2\n",
    "    \"\"\"\n",
    "    final_errors = []\n",
    "\n",
    "    for suffix, files in groups.items():\n",
    "        # Get the filenames for n and n' files\n",
    "        n_file = files[\"file1\"]  # e.g., N_1hee1.txt\n",
    "        n_prime_file = files[\"file2\"]  # e.g., N_2hee1.txt\n",
    "\n",
    "        # Match error files based on file structure\n",
    "        error_file_1_matches = [ef for ef in error_files_1 if suffix in ef]\n",
    "        error_file_2_matches = [ef for ef in error_files_2 if suffix.replace(\"1h\", \"2h\") in ef]\n",
    "\n",
    "\n",
    "        # Ensure both error files exist\n",
    "        if not error_file_1_matches or not error_file_2_matches:\n",
    "            print(f\"Error: Missing error file for suffix {suffix}. Skipping...\")\n",
    "            continue  # Skip this group if any file is missing\n",
    "\n",
    "        error_file_1 = error_file_1_matches[0]\n",
    "        error_file_2 = error_file_2_matches[0]\n",
    "\n",
    "        # Read values and errors\n",
    "        n, n_prime = read_values_and_errors(n_file, n_prime_file)\n",
    "        dn, dn_prime = read_values_and_errors(error_file_1, error_file_2)\n",
    "\n",
    "        # Calculate the denominator (2n + n')\n",
    "        denominator = 2 * n + n_prime\n",
    "\n",
    "        # Calculate the individual terms in the formula\n",
    "        term1 = (dn / n) ** 2\n",
    "        term2 = (dn_prime / denominator) ** 2\n",
    "\n",
    "        # Calculate the final error squared\n",
    "        final_error_squared = term1 + term2\n",
    "\n",
    "        # Append the final error (squared)\n",
    "        final_errors.append((suffix, final_error_squared))\n",
    "    \n",
    "    return final_errors\n",
    "\n",
    "\n",
    "# Example Usage\n",
    "n_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\"]\n",
    "n_prime_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\"]\n",
    "\n",
    "n_error_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\"]\n",
    "n_prime_error_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\"]\n",
    "\n",
    "# Group files by their suffix\n",
    "groups = group_files_by_suffix(n_files, n_prime_files)\n",
    "\n",
    "# Calculate final errors\n",
    "final_errors = calculate_final_error(groups, n_error_files, n_prime_error_files)\n",
    "\n",
    "# Print the results\n",
    "for suffix, error in final_errors:\n",
    "    print(f\"Final error squared for group {suffix}: {error}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8fb579f1",
   "metadata": {},
   "outputs": [],
   "source": [
    "import math\n",
    "\n",
    "# Function to read values and errors\n",
    "def read_values_and_errors(file1, file2):\n",
    "    \"\"\"\n",
    "    Reads a pair of values from two files and returns the values as floats.\n",
    "    \"\"\"\n",
    "    with open(file1, 'r') as f1, open(file2, 'r') as f2:\n",
    "        value1 = float(f1.read().strip())\n",
    "        value2 = float(f2.read().strip())\n",
    "    return value1, value2\n",
    "\n",
    "# Group files by their suffix (e.g., \"hee1\")\n",
    "def group_files_by_suffix(file_list_1, file_list_2):\n",
    "    \"\"\"\n",
    "    Groups files based on their shared suffix (e.g., \"hee1\").\n",
    "    Assumes filenames follow the format N_<group>.txt.\n",
    "    \"\"\"\n",
    "    groups = {}\n",
    "\n",
    "    for f1, f2 in zip(file_list_1, file_list_2):\n",
    "        # Extract the shared suffix (e.g., \"hee1\")\n",
    "        suffix = f1.split('_')[1].replace('.txt', '')  # Extract the part after '_'\n",
    "        groups[suffix] = {\"file1\": f1, \"file2\": f2}\n",
    "    \n",
    "    return groups\n",
    "\n",
    "# Function to calculate the final error\n",
    "def calculate_final_error(groups, error_files_1, error_files_2):\n",
    "    \"\"\"\n",
    "    Calculates the final error using the formula:\n",
    "    (\\delta_\\epsilon / \\epsilon)^2 = (\\delta_n / n)^2 + (\\delta_{2n + n'}) / (2n + n')^2\n",
    "    \"\"\"\n",
    "    final_errors = []\n",
    "\n",
    "    for suffix, files in groups.items():\n",
    "        # Get the filenames for n and n' files\n",
    "        n_file = files[\"file1\"]  # e.g., N_1hee1.txt\n",
    "        n_prime_file = files[\"file2\"]  # e.g., N_2hee1.txt\n",
    "\n",
    "        # Match error files based on file structure\n",
    "        error_file_1_matches = [ef for ef in error_files_1 if suffix in ef]\n",
    "        error_file_2_matches = [ef for ef in error_files_2 if suffix.replace(\"1h\", \"2h\") in ef]\n",
    "\n",
    "\n",
    "        # Ensure both error files exist\n",
    "        if not error_file_1_matches or not error_file_2_matches:\n",
    "            print(f\"Error: Missing error file for suffix {suffix}. Skipping...\")\n",
    "            continue  # Skip this group if any file is missing\n",
    "\n",
    "        error_file_1 = error_file_1_matches[0]\n",
    "        error_file_2 = error_file_2_matches[0]\n",
    "\n",
    "        # Read values and errors\n",
    "        n, n_prime = read_values_and_errors(n_file, n_prime_file)\n",
    "        dn, dn_prime = read_values_and_errors(error_file_1, error_file_2)\n",
    "\n",
    "        # Calculate the denominator (2n + n')\n",
    "        denominator = 2 * n + n_prime\n",
    "\n",
    "        # Calculate the individual terms in the formula\n",
    "        term1 = (dn / n) ** 2\n",
    "        term2 = (dn_prime / denominator) ** 2\n",
    "\n",
    "        # Calculate the final error squared\n",
    "        final_error_squared = term1 + term2\n",
    "\n",
    "        # Append the final error (squared)\n",
    "        final_errors.append((suffix, final_error_squared))\n",
    "    \n",
    "    return final_errors\n",
    "\n",
    "\n",
    "# Example Usage\n",
    "n_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\"]\n",
    "n_prime_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\"]\n",
    "\n",
    "n_error_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\"]\n",
    "n_prime_error_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\"]\n",
    "\n",
    "# Group files by their suffix\n",
    "groups = group_files_by_suffix(n_files, n_prime_files)\n",
    "\n",
    "# Calculate final errors\n",
    "final_errors = calculate_final_error(groups, n_error_files, n_prime_error_files)\n",
    "\n",
    "# Print the results\n",
    "for suffix, error in final_errors:\n",
    "    print(f\"Final error squared for group {suffix}: {error}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "3d088c7d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Final error squared for group 1hee1: 0.0009358969927549031\n",
      "Final error squared for group 1hee2: 0.0009602182987284052\n",
      "Final error squared for group 1hee3: 0.0010040051546537413\n",
      "Final error squared for group 1hbb7: 0.0007453882260237354\n",
      "Final error squared for group 1hbb8: 0.0006480806230196539\n",
      "Final error squared for group 1hbb9: 0.0008670649692484634\n",
      "Final error squared for group 1hbe4: 0.0006282115445206181\n",
      "Final error squared for group 1hbe5: 0.0005910793580087481\n",
      "Final error squared for group 1hbe6: 0.0007130068165834612\n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "\n",
    "# Function to read values and errors\n",
    "def read_values_and_errors(file1, file2):\n",
    "    \"\"\"\n",
    "    Reads a pair of values from two files and returns the values as floats.\n",
    "    \"\"\"\n",
    "    with open(file1, 'r') as f1, open(file2, 'r') as f2:\n",
    "        value1 = float(f1.read().strip())\n",
    "        value2 = float(f2.read().strip())\n",
    "    return value1, value2\n",
    "\n",
    "# Group files by their suffix (e.g., \"hee1\")\n",
    "def group_files_by_suffix(file_list_1, file_list_2):\n",
    "    \"\"\"\n",
    "    Groups files based on their shared suffix (e.g., \"hee1\").\n",
    "    Assumes filenames follow the format N_<group>.txt.\n",
    "    \"\"\"\n",
    "    groups = {}\n",
    "\n",
    "    for f1, f2 in zip(file_list_1, file_list_2):\n",
    "        # Extract the shared suffix (e.g., \"hee1\")\n",
    "        suffix = f1.split('_')[1].replace('.txt', '')  # Extract the part after '_'\n",
    "        groups[suffix] = {\"file1\": f1, \"file2\": f2}\n",
    "    \n",
    "    return groups\n",
    "\n",
    "# Function to calculate the final error\n",
    "def calculate_final_error(groups, error_files_1, error_files_2):\n",
    "    \"\"\"\n",
    "    Calculates the final error using the formula:\n",
    "    (\\delta_\\epsilon / \\epsilon)^2 = (\\delta_n / n)^2 + (\\delta_{2n + n'}) / (2n + n')^2\n",
    "    \"\"\"\n",
    "    final_errors = []\n",
    "\n",
    "    for suffix, files in groups.items():\n",
    "        # Get the filenames for n and n' files\n",
    "        n_file = files[\"file1\"]  # e.g., N_1hee1.txt\n",
    "        n_prime_file = files[\"file2\"]  # e.g., N_2hee1.txt\n",
    "\n",
    "        # Match error files based on file structure\n",
    "        error_file_1_matches = [ef for ef in error_files_1 if suffix in ef]\n",
    "        error_file_2_matches = [ef for ef in error_files_2 if suffix.replace(\"1h\", \"2h\") in ef]\n",
    "\n",
    "\n",
    "        # Ensure both error files exist\n",
    "        if not error_file_1_matches or not error_file_2_matches:\n",
    "            print(f\"Error: Missing error file for suffix {suffix}. Skipping...\")\n",
    "            continue  # Skip this group if any file is missing\n",
    "\n",
    "        error_file_1 = error_file_1_matches[0]\n",
    "        error_file_2 = error_file_2_matches[0]\n",
    "\n",
    "        # Read values and errors\n",
    "        n, n_prime = read_values_and_errors(n_file, n_prime_file)\n",
    "        dn, dn_prime = read_values_and_errors(error_file_1, error_file_2)\n",
    "\n",
    "        # Calculate the denominator (2n + n')\n",
    "        denominator = 2 * n + n_prime\n",
    "\n",
    "        # Calculate the individual terms in the formula\n",
    "        term1 = (dn / n) ** 2\n",
    "        term2 = (dn_prime / denominator) ** 2\n",
    "\n",
    "        # Calculate the final error squared\n",
    "        final_error_squared = term1 + term2\n",
    "\n",
    "        # Append the final error (squared)\n",
    "        final_errors.append((suffix, final_error_squared))\n",
    "    \n",
    "    return final_errors\n",
    "\n",
    "\n",
    "# Example Usage\n",
    "n_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\",\"N_1hbb7.txt\",\"N_1hbb8.txt\",\"N_1hbb9.txt\",\"N_1hbe4.txt\",\"N_1hbe5.txt\",\"N_1hbe6.txt\"]\n",
    "n_prime_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\",\"N_2hbb7.txt\",\"N_2hbb8.txt\",\"N_2hbb9.txt\",\"N_2hbe4.txt\",\"N_2hbe5.txt\",\"N_2hbe6.txt\"]\n",
    "\n",
    "n_error_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\",\"eN_1hbb7.txt\",\"eN_1hbb8.txt\",\"eN_1hbb9.txt\",\"eN_1hbe4.txt\",\"eN_1hbe5.txt\",\"eN_1hbe6.txt\"]\n",
    "n_prime_error_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\",\"eN_2hbb7.txt\",\"eN_2hbb8.txt\",\"eN_2hbb9.txt\",\"eN_2hbe4.txt\",\"eN_2hbe5.txt\",\"eN_2hbe6.txt\"]\n",
    "\n",
    "# Group files by their suffix\n",
    "groups = group_files_by_suffix(n_files, n_prime_files)\n",
    "\n",
    "# Calculate final errors\n",
    "final_errors = calculate_final_error(groups, n_error_files, n_prime_error_files)\n",
    "\n",
    "# Print the results\n",
    "for suffix, error in final_errors:\n",
    "    print(f\"Final error squared for group {suffix}: {error}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "058e3257",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Final error squared for group 1Iee1: 0.001718839761879635\n",
      "Final error squared for group 1Iee2: 0.001518635853659169\n",
      "Final error squared for group 1Iee3: 0.0036654019375770815\n",
      "Final error squared for group 1Ibb9: 0.0018153923658068268\n",
      "Final error squared for group 1Ibb10: 0.0019311077312886911\n",
      "Final error squared for group 1Ibb11: 0.0019421741741463172\n",
      "Final error squared for group 1Ibe4: 0.0009419450653309044\n",
      "Final error squared for group 1Ibe5: 0.0010270575515952673\n",
      "Final error squared for group 1Ibe6: 0.001191166917400971\n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "\n",
    "# Function to read values and errors\n",
    "def read_values_and_errors(file1, file2):\n",
    "    \"\"\"\n",
    "    Reads a pair of values from two files and returns the values as floats.\n",
    "    \"\"\"\n",
    "    with open(file1, 'r') as f1, open(file2, 'r') as f2:\n",
    "        value1 = float(f1.read().strip())\n",
    "        value2 = float(f2.read().strip())\n",
    "    return value1, value2\n",
    "\n",
    "# Group files by their suffix (e.g., \"hee1\")\n",
    "def group_files_by_suffix(file_list_1, file_list_2):\n",
    "    \"\"\"\n",
    "    Groups files based on their shared suffix (e.g., \"hee1\").\n",
    "    Assumes filenames follow the format N_<group>.txt.\n",
    "    \"\"\"\n",
    "    groups = {}\n",
    "\n",
    "    for f1, f2 in zip(file_list_1, file_list_2):\n",
    "        # Extract the shared suffix (e.g., \"hee1\")\n",
    "        suffix = f1.split('_')[1].replace('.txt', '')  # Extract the part after '_'\n",
    "        groups[suffix] = {\"file1\": f1, \"file2\": f2}\n",
    "    \n",
    "    return groups\n",
    "\n",
    "# Function to calculate the final error\n",
    "def calculate_final_error(groups, error_files_1, error_files_2):\n",
    "    \"\"\"\n",
    "    Calculates the final error using the formula:\n",
    "    (\\delta_\\epsilon / \\epsilon)^2 = (\\delta_n / n)^2 + (\\delta_{2n + n'}) / (2n + n')^2\n",
    "    \"\"\"\n",
    "    final_errors = []\n",
    "\n",
    "    for suffix, files in groups.items():\n",
    "        # Get the filenames for n and n' files\n",
    "        n_file = files[\"file1\"]  # e.g., N_1hee1.txt\n",
    "        n_prime_file = files[\"file2\"]  # e.g., N_2hee1.txt\n",
    "\n",
    "        # Match error files based on file structure\n",
    "        error_file_1_matches = [ef for ef in error_files_1 if suffix in ef]\n",
    "        error_file_2_matches = [ef for ef in error_files_2 if suffix.replace(\"1I\", \"2I\") in ef]\n",
    "\n",
    "\n",
    "        # Ensure both error files exist\n",
    "        if not error_file_1_matches or not error_file_2_matches:\n",
    "            print(f\"Error: Missing error file for suffix {suffix}. Skipping...\")\n",
    "            continue  # Skip this group if any file is missing\n",
    "\n",
    "        error_file_1 = error_file_1_matches[0]\n",
    "        error_file_2 = error_file_2_matches[0]\n",
    "\n",
    "        # Read values and errors\n",
    "        n, n_prime = read_values_and_errors(n_file, n_prime_file)\n",
    "        dn, dn_prime = read_values_and_errors(error_file_1, error_file_2)\n",
    "\n",
    "        # Calculate the denominator (2n + n')\n",
    "        denominator = 2 * n + n_prime\n",
    "\n",
    "        # Calculate the individual terms in the formula\n",
    "        term1 = (dn / n) ** 2\n",
    "        term2 = (dn_prime / denominator) ** 2\n",
    "\n",
    "        # Calculate the final error squared\n",
    "        final_error_squared = term1 + term2\n",
    "\n",
    "        # Append the final error (squared)\n",
    "        final_errors.append((suffix, final_error_squared))\n",
    "    \n",
    "    return final_errors\n",
    "\n",
    "\n",
    "# Example Usage\n",
    "n_files = [\"N_1Iee1.txt\", \"N_1Iee2.txt\", \"N_1Iee3.txt\",\"N_1Ibb9.txt\",\"N_1Ibb10.txt\",\"N_1Ibb11.txt\",\"N_1Ibe4.txt\",\"N_1Ibe5.txt\",\"N_1Ibe6.txt\"]\n",
    "n_prime_files = [\"N_2Iee1.txt\", \"N_2Iee2.txt\", \"N_2Iee3.txt\",\"N_2Ibb9.txt\",\"N_2Ibb10.txt\",\"N_2Ibb11.txt\",\"N_2Ibe4.txt\",\"N_2Ibe5.txt\",\"N_2Ibe6.txt\"]\n",
    "\n",
    "n_error_files = [\"eN_1Iee1.txt\", \"eN_1Iee2.txt\", \"eN_1Iee3.txt\",\"eN_1Ibb9.txt\",\"eN_1Ibb10.txt\",\"eN_1Ibb11.txt\",\"eN_1Ibe4.txt\",\"eN_1Ibe5.txt\",\"eN_1Ibe6.txt\"]\n",
    "n_prime_error_files = [\"eN_2Iee1.txt\", \"eN_2Iee2.txt\", \"eN_2Iee3.txt\",\"eN_2Ibb9.txt\",\"eN_2Ibb10.txt\",\"eN_2Ibb11.txt\",\"eN_2Ibe4.txt\",\"eN_2Ibe5.txt\",\"eN_2Ibe6.txt\"]\n",
    "\n",
    "# Group files by their suffix\n",
    "groups = group_files_by_suffix(n_files, n_prime_files)\n",
    "\n",
    "# Calculate final errors\n",
    "final_errors = calculate_final_error(groups, n_error_files, n_prime_error_files)\n",
    "\n",
    "# Print the results\n",
    "for suffix, error in final_errors:\n",
    "    print(f\"Final error squared for group {suffix}: {error}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "c82b4c74",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.00264 0.00247 0.001366\n",
      "0.00156 0.00161 0.0019000000000000002\n",
      "0.00255 0.0025700000000000002 0.0028\n",
      "*******\n",
      "4.2162000000000004e-07 5.5358e-07 9.6669e-07\n",
      "4.3467999999999997e-07 5.9759e-07 9.9927e-07\n",
      "7.5935e-07 1.3403400000000002e-06 1.70057e-06\n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "erepEE_1 = 0.00093+0.00171\n",
    "erepEE_2 = 0.00096+0.00151\n",
    "erepEE_3 = 0.00100+0.000366\n",
    "erepBE_1 = 0.00062+0.00094\n",
    "erepBE_2 = 0.00059+0.00102\n",
    "erepBE_3 = 0.00071+0.00119\n",
    "erepBB_1 = 0.00074+0.00181\n",
    "erepBB_2 = 0.00064+0.00193\n",
    "erepBB_3 = 0.00086+0.00194\n",
    "print(erepEE_1,erepEE_2,erepEE_3)\n",
    "print(erepBE_1,erepBE_2,erepBE_3)\n",
    "print(erepBB_1,erepBB_2,erepBB_3)\n",
    "print(\"*******\")\n",
    "ernEE_1 = (2.5243+1.6919)*math.pow(10,-7)\n",
    "ernEE_2 = (3.0788+2.4570)*math.pow(10,-7)\n",
    "ernEE_3 = (5.1076+4.5593)*math.pow(10,-7)\n",
    "ernBE_1 = (2.2768+2.0700)*math.pow(10,-7)\n",
    "ernBE_2 = (2.8715+3.1044)*math.pow(10,-7)\n",
    "ernBE_3 = (4.5402+5.4525)*math.pow(10,-7)\n",
    "ernBB_1 = (3.9392+3.6543)*math.pow(10,-7)\n",
    "ernBB_2 = (4.7655+8.6379)*math.pow(10,-7)\n",
    "ernBB_3 = (8.0408+8.9649)*math.pow(10,-7)\n",
    "print(ernEE_1,ernEE_2,ernEE_3)\n",
    "print(ernBE_1,ernBE_2,ernBE_3)\n",
    "print(ernBB_1,ernBB_2,ernBB_3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "d62196a3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Result for set 1: 2.5243262710218377e-07\n",
      "Result for set 2: 3.07886655752429e-07\n",
      "Result for set 3: 5.107658367858631e-07\n",
      "Result for set 4: 3.93924588518439e-07\n",
      "Result for set 5: 4.765530969209052e-07\n",
      "Result for set 6: 8.040850419286541e-07\n",
      "Result for set 7: 2.2768434023623824e-07\n",
      "Result for set 8: 2.871517843938897e-07\n",
      "Result for set 9: 4.540252989368545e-07\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "\n",
    "# Helper function to read a value and its uncertainty from a file\n",
    "def read_value_and_uncertainty(filename, default_uncertainty=1.0):\n",
    "    try:\n",
    "        with open(filename, 'r') as file:\n",
    "            # Read the first line and attempt to split into one value\n",
    "            line = file.readline().strip()\n",
    "\n",
    "            # Skip empty lines\n",
    "            if not line:\n",
    "                raise ValueError(f\"Empty line in file: {filename}\")\n",
    "            \n",
    "            # Only one value is expected\n",
    "            value = float(line)\n",
    "            return value, default_uncertainty\n",
    "            \n",
    "    except Exception as e:\n",
    "        print(f\"Error reading {filename}: {e}\")\n",
    "        return None, None  # Return None to indicate a problem\n",
    "\n",
    "# Function to calculate epsilon\n",
    "def calculate_epsilon(N1, N2):\n",
    "    return (2 * N2) / (2 * N2 + N1)\n",
    "\n",
    "# Function to calculate (delta_N / N)^2\n",
    "def calculate_delta_N_over_N_squared(n1_file, n2_file, n1_error_file, n2_error_file):\n",
    "    results = []  # Initialize an empty list to store results\n",
    "\n",
    "    for i in range(len(n1_file)):\n",
    "        # Read N1 and N2 values and their uncertainties\n",
    "        N1, delta_N1 = read_value_and_uncertainty(n1_file[i])\n",
    "        N2, delta_N2 = read_value_and_uncertainty(n2_file[i])\n",
    "\n",
    "        if N1 is None or N2 is None:\n",
    "            print(f\"Skipping calculation for set {i+1} due to missing or invalid data.\")\n",
    "            continue\n",
    "\n",
    "        # Assume constant uncertainties for the N1 and N2 files (e.g., default value of 1.0)\n",
    "        _, delta_N1_error = read_value_and_uncertainty(n1_error_file[i], default_uncertainty=1.0)\n",
    "        _, delta_N2_error = read_value_and_uncertainty(n2_error_file[i], default_uncertainty=1.0)\n",
    "\n",
    "        if delta_N1_error is None or delta_N2_error is None:\n",
    "            print(f\"Skipping calculation for set {i+1} due to missing uncertainties.\")\n",
    "            continue\n",
    "\n",
    "        # Calculate epsilon\n",
    "        epsilon = calculate_epsilon(N1, N2)\n",
    "\n",
    "        # Calculate relative uncertainties\n",
    "        delta_N2_over_N2 = delta_N2 / N2\n",
    "\n",
    "        # Propagate uncertainty through epsilon formula\n",
    "        delta_epsilon = np.abs(2 * N2 / (2 * N2 + N1)**2) * delta_N1 + np.abs(-2 / (2 * N2 + N1)) * delta_N2\n",
    "        term2 = delta_epsilon / (2 * epsilon * (1 - epsilon))\n",
    "\n",
    "        # Calculate (delta_N / N)^2\n",
    "        delta_N_over_N_squared = delta_N2_over_N2**2 + term2**2\n",
    "        results.append(delta_N_over_N_squared)\n",
    "\n",
    "    return results\n",
    "\n",
    "# Example usage\n",
    "n1_file = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\", \"N_1hbb7.txt\", \"N_1hbb8.txt\", \"N_1hbb9.txt\", \"N_1hbe4.txt\", \"N_1hbe5.txt\", \"N_1hbe6.txt\"]\n",
    "n2_file = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\", \"N_2hbb7.txt\", \"N_2hbb8.txt\", \"N_2hbb9.txt\", \"N_2hbe4.txt\", \"N_2hbe5.txt\", \"N_2hbe6.txt\"]\n",
    "n1_error_file = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\", \"eN_1hbb7.txt\", \"eN_1hbb8.txt\", \"eN_1hbb9.txt\", \"eN_1hbe4.txt\", \"eN_1hbe5.txt\", \"eN_1hbe6.txt\"]\n",
    "n2_error_file = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\", \"eN_2hbb7.txt\", \"eN_2hbb8.txt\", \"eN_2hbb9.txt\", \"eN_2hbe4.txt\", \"eN_2hbe5.txt\", \"eN_2hbe6.txt\"]\n",
    "\n",
    "# Loop through all the files and calculate the result for each pair\n",
    "results = calculate_delta_N_over_N_squared(n1_file, n2_file, n1_error_file, n2_error_file)\n",
    "\n",
    "# Print results\n",
    "for i, result in enumerate(results):\n",
    "    print(f\"Result for set {i+1}: {result}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "b709f28b",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Result for set 1: 1.691963323786033e-07\n",
      "Result for set 2: 2.4570905761608477e-07\n",
      "Result for set 3: 4.559327251164106e-07\n",
      "Result for set 4: 3.654311045416467e-07\n",
      "Result for set 5: 8.637976100394578e-07\n",
      "Result for set 6: 8.964979968264938e-07\n",
      "Result for set 7: 2.0700345936944278e-07\n",
      "Result for set 8: 3.1044386465338073e-07\n",
      "Result for set 9: 5.452548059500491e-07\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "\n",
    "# Helper function to read a value and its uncertainty from a file\n",
    "def read_value_and_uncertainty(filename, default_uncertainty=1.0):\n",
    "    try:\n",
    "        with open(filename, 'r') as file:\n",
    "            # Read the first line and attempt to split into one value\n",
    "            line = file.readline().strip()\n",
    "\n",
    "            # Skip empty lines\n",
    "            if not line:\n",
    "                raise ValueError(f\"Empty line in file: {filename}\")\n",
    "            \n",
    "            # Only one value is expected\n",
    "            value = float(line)\n",
    "            return value, default_uncertainty\n",
    "            \n",
    "    except Exception as e:\n",
    "        print(f\"Error reading {filename}: {e}\")\n",
    "        return None, None  # Return None to indicate a problem\n",
    "\n",
    "# Function to calculate epsilon\n",
    "def calculate_epsilon(N1, N2):\n",
    "    return (2 * N2) / (2 * N2 + N1)\n",
    "\n",
    "# Function to calculate (delta_N / N)^2\n",
    "def calculate_delta_N_over_N_squared(n1_file, n2_file, n1_error_file, n2_error_file):\n",
    "    results = []  # Initialize an empty list to store results\n",
    "\n",
    "    for i in range(len(n1_file)):\n",
    "        # Read N1 and N2 values and their uncertainties\n",
    "        N1, delta_N1 = read_value_and_uncertainty(n1_file[i])\n",
    "        N2, delta_N2 = read_value_and_uncertainty(n2_file[i])\n",
    "\n",
    "        if N1 is None or N2 is None:\n",
    "            print(f\"Skipping calculation for set {i+1} due to missing or invalid data.\")\n",
    "            continue\n",
    "\n",
    "        # Assume constant uncertainties for the N1 and N2 files (e.g., default value of 1.0)\n",
    "        _, delta_N1_error = read_value_and_uncertainty(n1_error_file[i], default_uncertainty=1.0)\n",
    "        _, delta_N2_error = read_value_and_uncertainty(n2_error_file[i], default_uncertainty=1.0)\n",
    "\n",
    "        if delta_N1_error is None or delta_N2_error is None:\n",
    "            print(f\"Skipping calculation for set {i+1} due to missing uncertainties.\")\n",
    "            continue\n",
    "\n",
    "        # Calculate epsilon\n",
    "        epsilon = calculate_epsilon(N1, N2)\n",
    "\n",
    "        # Calculate relative uncertainties\n",
    "        delta_N2_over_N2 = delta_N2 / N2\n",
    "\n",
    "        # Propagate uncertainty through epsilon formula\n",
    "        delta_epsilon = np.abs(2 * N2 / (2 * N2 + N1)**2) * delta_N1 + np.abs(-2 / (2 * N2 + N1)) * delta_N2\n",
    "        term2 = delta_epsilon / (2 * epsilon * (1 - epsilon))\n",
    "\n",
    "        # Calculate (delta_N / N)^2\n",
    "        delta_N_over_N_squared = delta_N2_over_N2**2 + term2**2\n",
    "        results.append(delta_N_over_N_squared)\n",
    "\n",
    "    return results\n",
    "\n",
    "# Example usage\n",
    "n1_file = [\"N_1Iee1.txt\", \"N_1Iee2.txt\", \"N_1Iee3.txt\", \"N_1Ibb9.txt\", \"N_1Ibb10.txt\", \"N_1Ibb11.txt\", \"N_1Ibe4.txt\", \"N_1Ibe5.txt\", \"N_1Ibe6.txt\"]\n",
    "n2_file = [\"N_2Iee1.txt\", \"N_2Iee2.txt\", \"N_2Iee3.txt\", \"N_2Ibb9.txt\", \"N_2Ibb10.txt\", \"N_2Ibb11.txt\", \"N_2Ibe4.txt\", \"N_2Ibe5.txt\", \"N_2Ibe6.txt\"]\n",
    "n1_error_file = [\"eN_1Iee1.txt\", \"eN_1Iee2.txt\", \"eN_1Iee3.txt\", \"eN_1Ibb9.txt\", \"eN_1Ibb10.txt\", \"eN_1Ibb11.txt\", \"eN_1Ibe4.txt\", \"eN_1Ibe5.txt\", \"eN_1Ibe6.txt\"]\n",
    "n2_error_file = [\"eN_2Iee1.txt\", \"eN_2Iee2.txt\", \"eN_2Iee3.txt\", \"eN_2Ibb9.txt\", \"eN_2Ibb10.txt\", \"eN_2Ibb11.txt\", \"eN_2Ibe4.txt\", \"eN_2Ibe5.txt\", \"eN_2Ibe6.txt\"]\n",
    "\n",
    "# Loop through all the files and calculate the result for each pair\n",
    "results = calculate_delta_N_over_N_squared(n1_file, n2_file, n1_error_file, n2_error_file)\n",
    "\n",
    "# Print results\n",
    "for i, result in enumerate(results):\n",
    "    print(f\"Result for set {i+1}: {result}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "a2f26ac2",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'np' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m/tmp/ipykernel_471/3819762956.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     29\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     30\u001b[0m \u001b[0;31m# Load all input data for the first set\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 31\u001b[0;31m \u001b[0mN1\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mload_data\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mN1_files\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     32\u001b[0m \u001b[0mN2\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mload_data\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mN2_files\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     33\u001b[0m \u001b[0mN1_prime\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mload_data\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mN1_prime_files\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/tmp/ipykernel_471/3819762956.py\u001b[0m in \u001b[0;36mload_data\u001b[0;34m(file_list)\u001b[0m\n\u001b[1;32m     16\u001b[0m \u001b[0;31m# Load data from text files\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     17\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mload_data\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 18\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mloadtxt\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mfile\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mfile_list\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     19\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     20\u001b[0m \u001b[0;31m# File names for inputs\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/tmp/ipykernel_471/3819762956.py\u001b[0m in \u001b[0;36m<listcomp>\u001b[0;34m(.0)\u001b[0m\n\u001b[1;32m     16\u001b[0m \u001b[0;31m# Load data from text files\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     17\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mload_data\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 18\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mloadtxt\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mfile\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mfile_list\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     19\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     20\u001b[0m \u001b[0;31m# File names for inputs\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mNameError\u001b[0m: name 'np' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) ** 2) / (4 * N2)\n",
    "    term3 = ((2 * N2 + N1) * (2 * N2_prime + N1_prime)) / (4 * N2 * N2_prime)\n",
    "    return term1 * term2 * term3\n",
    "\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = ((4 * delta_N2 ** 2 + delta_N1 ** 2) / (2 * N2 + N1)) ** 2\n",
    "    term4 = ((4 * delta_N2_prime ** 2 + delta_N1_prime ** 2) / (2 * N2_prime + N1_prime)) ** 2\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "# Load data from text files\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\"]\n",
    "N2_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\"]\n",
    "N1_prime_files = [\"N_1Iee1.txt\", \"N_1Iee2.txt\", \"N_1Iee3.txt\"]\n",
    "N2_prime_files = [\"N_2Iee1.txt\", \"N_2Iee2.txt\", \"N_2Iee3.txt\"]\n",
    "delta_N1_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\"]\n",
    "delta_N2_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Iee1.txt\", \"eN_1Iee2.txt\", \"eN_1Iee3.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Iee1.txt\", \"eN_2Iee2.txt\", \"eN_2Iee3.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.018*0.31)\n",
    "constant_value_2 =  0.000001582 \n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "\n",
    "# File names for inputs (second set of data)\n",
    "N1_files2 = [\"N_1hbb7.txt\", \"N_1hbb8.txt\", \"N_1hbb9.txt\"] \n",
    "N2_files2 = [\"N_2hbb7.txt\", \"N_2hbb8.txt\", \"N_2hbb9.txt\"]\n",
    "N1_prime_files2 = [\"N_1Ibb9.txt\", \"N_1Ibb10.txt\", \"N_1Ibb11.txt\"]\n",
    "N2_prime_files2 = [\"N_2Ibb9.txt\", \"N_2Ibb10.txt\", \"N_2Ibb11.txt\"]\n",
    "delta_N1_files2 = [\"eN_1hbb7.txt\", \"eN_1hbb8.txt\", \"eN_1hbb9.txt\"]\n",
    "delta_N2_files2 = [\"eN_2hbb7.txt\", \"eN_2hbb8.txt\", \"eN_2hbb9.txt\"]\n",
    "delta_N1_prime_files2 = [\"eN_1Ibb9.txt\", \"eN_1Ibb10.txt\", \"eN_1Ibb11.txt\"]\n",
    "delta_N2_prime_files2 = [\"eN_2Ibb9.txt\", \"eN_2Ibb10.txt\", \"eN_2Ibb11.txt\"]\n",
    "\n",
    "# Load all input data for the second set\n",
    "N1_alt = load_data(N1_files2)\n",
    "N2_alt = load_data(N2_files2)\n",
    "N1_prime_alt = load_data(N1_prime_files2)\n",
    "N2_prime_alt = load_data(N2_prime_files2)\n",
    "delta_N1_alt = load_data(delta_N1_files2)\n",
    "delta_N2_alt = load_data(delta_N2_files2)\n",
    "delta_N1_prime_alt = load_data(delta_N1_prime_files2)\n",
    "delta_N2_prime_alt = load_data(delta_N2_prime_files2)\n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the second set of inputs\n",
    "L_values2 = []\n",
    "delta_L_over_L_squared_values2 = []\n",
    "for i in range(len(N1_alt)):\n",
    "    L = calculate_L(N1_alt[i], N2_alt[i], N1_prime_alt[i], N2_prime_alt[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1_alt[i], N2_alt[i], N1_prime_alt[i], N2_prime_alt[i], delta_N1_alt[i], delta_N2_alt[i], delta_N1_prime_alt[i], delta_N2_prime_alt[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values2.append(L)\n",
    "    delta_L_over_L_squared_values2.append(delta_L_squared)\n",
    "\n",
    "# File names for inputs (third set of data)\n",
    "N1_files3 = [\"N_1hbe4.txt\", \"N_1hbe5.txt\", \"N_1hbe6.txt\"]\n",
    "N2_files3 = [\"N_2hbe4.txt\", \"N_2hbe5.txt\", \"N_2hbe6.txt\"]\n",
    "N1_prime_files3 = [\"N_1Ibe4.txt\", \"N_1Ibe5.txt\", \"N_1Ibe6.txt\"]\n",
    "N2_prime_files3 = [\"N_2Ibe4.txt\", \"N_2Ibe5.txt\", \"N_2Ibe6.txt\"]\n",
    "delta_N1_files3 = [\"eN_1hbe4.txt\", \"eN_1hbe5.txt\", \"eN_1hbe6.txt\"]\n",
    "delta_N2_files3 = [\"eN_2hbe4.txt\", \"eN_2hbe5.txt\", \"eN_2hbe6.txt\"]\n",
    "delta_N1_prime_files3 = [\"eN_1Ibe4.txt\", \"eN_1Ibe5.txt\", \"eN_1Ibe6.txt\"]\n",
    "delta_N2_prime_files3 = [\"eN_2Ibe4.txt\", \"eN_2Ibe5.txt\", \"eN_2Ibe6.txt\"]\n",
    "\n",
    "# Load all input data for the third set\n",
    "N1_altt = load_data(N1_files3)\n",
    "N2_altt = load_data(N2_files3)\n",
    "N1_prime_altt = load_data(N1_prime_files3)\n",
    "N2_prime_altt = load_data(N2_prime_files3)\n",
    "delta_N1_altt = load_data(delta_N1_files3)\n",
    "delta_N2_altt = load_data(delta_N2_files3)\n",
    "delta_N1_prime_altt = load_data(delta_N1_prime_files3)\n",
    "delta_N2_prime_altt = load_data(delta_N2_prime_files3)\n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the third set of inputs\n",
    "L_values3 = []\n",
    "delta_L_over_L_squared_values3 = []\n",
    "for i in range(len(N1_altt)):\n",
    "    L = calculate_L(N1_altt[i], N2_altt[i], N1_prime_altt[i], N2_prime_altt[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1_altt[i], N2_altt[i], N1_prime_altt[i], N2_prime_altt[i], delta_N1_altt[i], delta_N2_altt[i], delta_N1_prime_altt[i], delta_N2_prime_altt[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values3.append(L)\n",
    "    delta_L_over_L_squared_values3.append(delta_L_squared)\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 42, 83\n",
    "x_bin_start3, x_bin_end3 = 83, 120\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_EE\",L_values1)\n",
    "print(\"errorlumi_EE\",delta_L_over_L_squared_values1)\n",
    "print(\"lumi_BB\",L_values2)\n",
    "print(\"errorlumi_BB\",delta_L_over_L_squared_values2)\n",
    "print(\"lumi_BE\",L_values3)\n",
    "print(\"errorlumi_BE\",delta_L_over_L_squared_values3)\n",
    "a = L_values1[0]+L_values2[0]+L_values3[0]\n",
    "b = L_values1[1]+L_values2[1]+L_values3[1]\n",
    "c = L_values1[2]+L_values2[2]+L_values3[2]\n",
    "alll = [a,b,c]\n",
    "da = delta_L_over_L_squared_values1[0]+delta_L_over_L_squared_values2[0]+delta_L_over_L_squared_values3[0]\n",
    "db = delta_L_over_L_squared_values1[1]+delta_L_over_L_squared_values2[1]+delta_L_over_L_squared_values3[1]\n",
    "dc = delta_L_over_L_squared_values1[2]+delta_L_over_L_squared_values2[2]+delta_L_over_L_squared_values3[2]\n",
    "allle = [da,db,dc]\n",
    "lbril_values = [116086.333 , 100081.51 , 93398.989]\n",
    "print(\"lumi_tot\",alll )\n",
    "print(\"erlumi_tot\",allle )\n",
    "\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.errorbar(lumisec_midpoints, alll ,yerr=allle , fmt='o', color='red',  capsize=5)\n",
    "plt.errorbar(lumisec_midpoints, lbril_values , fmt='o', color='black',  capsize=5)\n",
    "\n",
    "# plt.errorbar(lumisec_midpoints, L_values1, yerr=delta_L_over_L_squared_values1, fmt='o', color='black',  capsize=5)\n",
    "# plt.errorbar(lumisec_midpoints, L_values2, yerr=delta_L_over_L_squared_values2, fmt='o', color='blue',  capsize=5)\n",
    "# plt.errorbar(lumisec_midpoints, L_values3, yerr=delta_L_over_L_squared_values3, fmt='o', color='red',  capsize=5)\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"L\")\n",
    "plt.title(\"L vs Lumisec\")\n",
    "plt.grid()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "70aacf02",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import uproot\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) *(2 * N2_prime + N1_prime)) / (4*N2 * N2_prime)\n",
    "    term3 = ((2 * N2 + N1) **2) / (4*N2)\n",
    "    return term1 * term2 * term3\n",
    "\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = (4 * (delta_N2) ** 2 + (delta_N1) ** 2) / ((2 * N2 + N1) ** 2)\n",
    "    term4 = (4 * (delta_N2_prime) ** 2 + (delta_N1_prime) ** 2) / ((2 * N2_prime + N1_prime) ** 2)\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "# Load data from text files\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\"]\n",
    "N2_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\"]\n",
    "N1_prime_files = [\"N_1Iee1.txt\", \"N_1Iee2.txt\", \"N_1Iee3.txt\"]\n",
    "N2_prime_files = [\"N_2Iee1.txt\", \"N_2Iee2.txt\", \"N_2Iee3.txt\"]\n",
    "delta_N1_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\"]\n",
    "delta_N2_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Iee1.txt\", \"eN_1Iee2.txt\", \"eN_1Iee3.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Iee1.txt\", \"eN_2Iee2.txt\", \"eN_2Iee3.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.018*0.106)\n",
    "constant_value_2 =  0.00000369\n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 42, 83\n",
    "x_bin_start3, x_bin_end3 = 83, 120\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_EE\",L_values1)\n",
    "print(\"errorlumi_EE\",delta_L_over_L_squared_values1)\n",
    "\n",
    "rat = [lbril_values[0]/L_values1[0], lbril_values[1]/L_values1[1] , lbril_values[2]/L_values1[2]]\n",
    "lbril_values = [116086.333 , 100081.51 , 93398.989]\n",
    "\n",
    "print(\"bril\",lbril_values)\n",
    "\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.errorbar(lumisec_midpoints, rat , fmt='o', color='red',  capsize=5,label=\"lumi_bril/lumi_EE\")\n",
    "\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"lumi_bril/lumi_EE\")\n",
    "plt.legend()\n",
    "plt.grid()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "d0bf691c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "lumi_EE [293920.71242498746, 258091.74451378375, 198552.26262029275]\n",
      "errorlumi_EE [61.31920277443618, 43.91422437650629, 41.42379193686973]\n",
      "bril [116086.333, 100081.51, 93398.989]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x720 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import uproot\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "\n",
    "# Function to calculate L\n",
    "def calculate_L(N1, N2, N1_prime, N2_prime, constant_value_1):\n",
    "    term1 = (1 / constant_value_1)\n",
    "    term2 = ((2 * N2 + N1) ** 2) / (4 * N1)\n",
    "    term3 = ((2 * N2 + N1) * (2 * N2_prime + N1_prime)) / (4 * N2 * N2_prime)\n",
    "    return term1 * term2 * term3\n",
    "\n",
    "# Function to calculate (delta L / L)^2\n",
    "def calculate_delta_L_over_L_squared(N1, N2, N1_prime, N2_prime, delta_N1, delta_N2, delta_N1_prime, delta_N2_prime, constant_value_2, constant_value_3):\n",
    "    term1 = 3 * (delta_N2 / N2) ** 2\n",
    "    term2 = (delta_N2_prime / N2_prime) ** 2\n",
    "    term3 = ((4 * delta_N2 ** 2 + delta_N1 ** 2) / (2 * N2 + N1)) ** 2\n",
    "    term4 = ((4 * delta_N2_prime ** 2 + delta_N1_prime ** 2) / (2 * N2_prime + N1_prime)) ** 2\n",
    "    return term1 + term2 + term3 + term4 + constant_value_2 + constant_value_3\n",
    "\n",
    "# Load data from text files\n",
    "def load_data(file_list):\n",
    "    return [np.loadtxt(file) for file in file_list]\n",
    "\n",
    "# File names for inputs\n",
    "N1_files = [\"N_1hee1.txt\", \"N_1hee2.txt\", \"N_1hee3.txt\"]\n",
    "N2_files = [\"N_2hee1.txt\", \"N_2hee2.txt\", \"N_2hee3.txt\"]\n",
    "N1_prime_files = [\"N_1Iee1.txt\", \"N_1Iee2.txt\", \"N_1Iee3.txt\"]\n",
    "N2_prime_files = [\"N_2Iee1.txt\", \"N_2Iee2.txt\", \"N_2Iee3.txt\"]\n",
    "delta_N1_files = [\"eN_1hee1.txt\", \"eN_1hee2.txt\", \"eN_1hee3.txt\"]\n",
    "delta_N2_files = [\"eN_2hee1.txt\", \"eN_2hee2.txt\", \"eN_2hee3.txt\"]\n",
    "delta_N1_prime_files = [\"eN_1Iee1.txt\", \"eN_1Iee2.txt\", \"eN_1Iee3.txt\"]\n",
    "delta_N2_prime_files = [\"eN_2Iee1.txt\", \"eN_2Iee2.txt\", \"eN_2Iee3.txt\"]\n",
    "\n",
    "# Load all input data for the first set\n",
    "N1 = load_data(N1_files)\n",
    "N2 = load_data(N2_files)\n",
    "N1_prime = load_data(N1_prime_files)\n",
    "N2_prime = load_data(N2_prime_files)\n",
    "delta_N1 = load_data(delta_N1_files)\n",
    "delta_N2 = load_data(delta_N2_files)\n",
    "delta_N1_prime = load_data(delta_N1_prime_files)\n",
    "delta_N2_prime = load_data(delta_N2_prime_files)\n",
    "\n",
    "# Constants\n",
    "constant_value_1 = (2.073*0.097)\n",
    "constant_value_2 =  0.000001582 \n",
    "constant_value_3 =  0.000141 \n",
    "\n",
    "# Calculate L and (delta L / L)^2 for the first set of inputs\n",
    "L_values1 = []\n",
    "delta_L_over_L_squared_values1 = []\n",
    "for i in range(len(N1)):\n",
    "    L = calculate_L(N1[i], N2[i], N1_prime[i], N2_prime[i], constant_value_1)\n",
    "    delta_L_squared = calculate_delta_L_over_L_squared(\n",
    "        N1[i], N2[i], N1_prime[i], N2_prime[i], delta_N1[i], delta_N2[i], delta_N1_prime[i], delta_N2_prime[i],\n",
    "        constant_value_2, constant_value_3\n",
    "    )\n",
    "    L_values1.append(L)\n",
    "    delta_L_over_L_squared_values1.append(delta_L_squared)\n",
    "\n",
    "# Process the ROOT file\n",
    "demo_file = \"output_resultshlt.root\"\n",
    "with uproot.open(demo_file) as root_file_2:\n",
    "    uproot_hist = root_file_2[\"h_mass_2hlt_EE\"]\n",
    "    values, edges_lumisec, edges_mass = uproot_hist.to_numpy()\n",
    "\n",
    "# Bin ranges for projections\n",
    "x_bin_start1, x_bin_end1 = 1, 41\n",
    "x_bin_start2, x_bin_end2 = 41, 81\n",
    "x_bin_start3, x_bin_end3 = 81, 119\n",
    "\n",
    "# Calculate midpoints of lumisec bins\n",
    "lumisec_midpoints = [\n",
    "    (edges_lumisec[x_bin_start1] + edges_lumisec[x_bin_end1]) / 2,\n",
    "    (edges_lumisec[x_bin_start2] + edges_lumisec[x_bin_end2]) / 2,\n",
    "    (edges_lumisec[x_bin_start3] + edges_lumisec[x_bin_end3]) / 2,\n",
    "]\n",
    "\n",
    "# Plot the results\n",
    "plt.figure(figsize=(8, 10))\n",
    "print(\"lumi_EE\",L_values1)\n",
    "print(\"errorlumi_EE\",delta_L_over_L_squared_values1)\n",
    "\n",
    "lbril_values = [114618.486  , 97972.294 , 81904.476]\n",
    "\n",
    "print(\"bril\",lbril_values)\n",
    "# Plot L\n",
    "plt.subplot(2, 1, 1)\n",
    "plt.errorbar(lumisec_midpoints,L_values1  ,yerr= delta_L_over_L_squared_values1, fmt='o', color='red',  capsize=5)\n",
    "plt.errorbar(lumisec_midpoints, lbril_values , fmt='o', color='black',  capsize=5)\n",
    "\n",
    "plt.xlabel(\"Lumisec\")\n",
    "plt.ylabel(\"L\")\n",
    "plt.title(\"L vs Lumisec\")\n",
    "plt.grid()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "423868c5",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
